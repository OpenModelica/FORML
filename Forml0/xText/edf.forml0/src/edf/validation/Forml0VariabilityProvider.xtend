/*
 * generated by Xtext 2.22.0
 */
package edf.validation

import com.google.inject.Inject
import edf.forml0.AdditionExpression
import edf.forml0.AndExpression
import edf.forml0.BecomesExpression
import edf.forml0.Boolean
import edf.forml0.BooleanFromCtl
import edf.forml0.BooleanLiteral
import edf.forml0.ChangesExpression
import edf.forml0.Clock
import edf.forml0.Ctl
import edf.forml0.DifferenceExpression
import edf.forml0.DivisionExpression
import edf.forml0.DropExpression
import edf.forml0.EqualityExpression
import edf.forml0.Event
import edf.forml0.EventLiteral
import edf.forml0.EveryExpression
import edf.forml0.Expression
import edf.forml0.ExternalBooleanDefinition
import edf.forml0.ExternalEventDefinition
import edf.forml0.ExternalRealDefinition
import edf.forml0.FirstExpression
import edf.forml0.FollowingExpression
import edf.forml0.FunctionCall
import edf.forml0.GlobalBooleanDefinition
import edf.forml0.GlobalEventDefinition
import edf.forml0.GlobalEventOccurrence
import edf.forml0.GlobalEventRate
import edf.forml0.GlobalRealDefinition
import edf.forml0.GreaterOrEqualExpression
import edf.forml0.GreaterThanExpression
import edf.forml0.IfExpression
import edf.forml0.Integer
import edf.forml0.IntegerDefinition
import edf.forml0.IntegerDivisionExpression
import edf.forml0.Item
import edf.forml0.ItemizedBooleanDefinition
import edf.forml0.ItemizedEventDefinition
import edf.forml0.ItemizedRealDefinition
import edf.forml0.LeavesExpression
import edf.forml0.LessOrEqualExpression
import edf.forml0.LessThanExpression
import edf.forml0.MyClock
import edf.forml0.MyRate
import edf.forml0.MyValue
import edf.forml0.NotExpression
import edf.forml0.NumericLiteral
import edf.forml0.OrExpression
import edf.forml0.PowerExpression
import edf.forml0.ProductExpression
import edf.forml0.PropertyEvent
import edf.forml0.PropertyPfd
import edf.forml0.PropertyState
import edf.forml0.Real
import edf.forml0.Reference
import edf.forml0.SubstractionExpression
import edf.forml0.Time
import edf.forml0.UnaryMinusExpression
import edf.forml0.WhileExpression
import edf.forml0.WithoutExpression
import edf.forml0.XorExpression
import edf.forml0.inPTime
import edf.forml0.BuiltInFunctionCall
import edf.forml0.AttributeExpression

import static extension org.eclipse.xtext.EcoreUtil2.*

//=============================================================================
//
//	Variability computation for expressions and items
//	 - constant   (only for variables)
//	 - fixed      (only for variables)
//	 - increasing (only for numeric variables)
//	 - decreasing (only for numeric variables)
//	 - normal     (in all other cases)
//
//=============================================================================
interface Forml0Variability {override String toString()}
class constant   implements Forml0Variability {override String toString() {"constant"  }}
class fixed      implements Forml0Variability {override String toString() {"fixed"     }}
class increasing implements Forml0Variability {override String toString() {"increasing"}}
class decreasing implements Forml0Variability {override String toString() {"decreasing"}}
class normal     implements Forml0Variability {override String toString() {"normal"    }}

class Forml0VariabilityProvider {
	// Variability of expressions
	// constant is a subtype of fixed: it is allowed whenever constant is
	public static val constant   = new constant
	public static val fixed      = new fixed
	public static val increasing = new increasing
	public static val decreasing = new decreasing
	public static val normal     = new normal
	
	@Inject extension Forml0ValueProvider
	
	def dispatch Forml0Variability variabilityFor (Expression expr) {
		switch (expr) {
			NumericLiteral:				constant
			Time:						increasing
			inPTime:					increasing
		///	MyRate:
			PropertyPfd:				normal
		///	BuiltInFunctionCall:
		
			BooleanLiteral:				constant
			PropertyState:				normal
			BooleanFromCtl:				normal
			
			MyValue:					expr.getContainerOfType(typeof(Item)).variabilityFor
			
			EventLiteral:				normal
			PropertyEvent:				normal
			MyClock:					normal
			Clock:						normal
			Reference:					if (expr?.getContainerOfType(typeof(Item))?.name == expr?.identifier) normal else expr?.identifier?.variabilityFor
			FunctionCall:				normal
		
			AttributeExpression:		expr?.atom?.variabilityFor
		///	PowerExpression:
		///	UnaryMinusExpression:
			NotExpression:				normal
			FirstExpression:			normal
			DropExpression:				normal
		///	ProductExpression:
		///	DivisionExpression:
		///	IntegerDivisionExpression:
		///	AdditionExpression
		///	SubstractionExpression:
			WithoutExpression:			normal
			FollowingExpression:		normal
		///	EqualityExpression:	
		///	DifferenceExpression:
		///	LessThanExpression:	
		///	LessOrEqualExpression:
		///	GreaterThanExpression:
		///	GreaterOrEqualExpression:
		///	AndExpression:		
			WhileExpression:			normal
		///	OrExpression:				
		///	XorExpression:				
		///	IfExpression
			EveryExpression:			normal
			ChangesExpression:			normal
			BecomesExpression:			normal
			LeavesExpression:			normal
			
			Event:						normal
			Ctl:						normal
		}
	}
	
	def dispatch Forml0Variability variabilityFor (MyRate expr) {
		var definition = expr.getContainerOfType(typeof(Event))?.eventDefinition
		switch definition {
			GlobalEventDefinition:		normal
			ExternalEventDefinition:	normal
			ItemizedEventDefinition:	switch (definition.statement) {
				GlobalEventOccurrence:	normal
				GlobalEventRate:		constant
			}
		}
	}
 	
	def dispatch Forml0Variability variabilityFor (BuiltInFunctionCall expr) {
		 switch expr.function {
		 	case 'count': 		increasing
		 	case 'duration':    increasing
		 	case 'inPCount': 	increasing
		 	case 'inPuration':  increasing
		 	case 'inPMax':		increasing
		 	case 'inPMin':		decreasing
		 	case 'inTMax':		increasing
		 	case 'inTMin':		decreasing
		 	case 'probability': normal
		 }
	}
	
	def dispatch Forml0Variability variabilityFor (PowerExpression expr) {
		switch expr.left.variabilityFor {
			case expr.left.variabilityFor == constant:	constant
			case expr.left.variabilityFor == fixed:		fixed
			case expr.negative:							normal
			default:	 								expr.left.variabilityFor
		}
	}	
	
	def dispatch Forml0Variability variabilityFor (UnaryMinusExpression expr) {
		switch expr.right.variabilityFor {
			case constant:		constant
			case fixed:			fixed
			case increasing:	decreasing
			case decreasing:	increasing
			case normal:		normal
		}
	}	
	
	def dispatch Forml0Variability variabilityFor (ProductExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		var leftVal  = expr.left .valueFor
		var rightVal = expr.right.valueFor
		if (leftVar  == constant && leftVal  == 0.0) 	  					  constant   else
		if (rightVar == constant && rightVal == 0.0) 	  					  constant   else
		if (leftVar  == constant && rightVar == constant) 					  constant   else
		if (leftVar  == fixed    && rightVar == constant) 					  fixed      else
		if (leftVar  == constant && rightVar == fixed   ) 					  fixed      else
		if (leftVar  == constant && leftVal  < 0.0 && rightVar == increasing) decreasing else
		if (leftVar  == constant && leftVal  > 0.0 && rightVar == increasing) increasing else
		if (rightVar == constant && rightVal < 0.0 && leftVal  == increasing) decreasing else
		if (rightVar == constant && rightVal > 0.0 && leftVal  == increasing) increasing else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (DivisionExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		var leftVal  = expr.left .valueFor
		var rightVal = expr.right.valueFor
		if (leftVar  == constant && leftVal  == 0.0) 	  					  constant   else
		if (rightVar == constant && rightVal == 0.0) 	  					  constant   else
		if (leftVar  == constant && rightVar == constant) 					  constant   else
		if (leftVar  == fixed    && rightVar == constant) 					  fixed      else
		if (leftVar  == constant && rightVar == fixed   ) 					  fixed      else
		if (leftVar  == constant && leftVal  < 0.0 && rightVar == increasing) decreasing else
		if (leftVar  == constant && leftVal  > 0.0 && rightVar == increasing) increasing else
		if (rightVar == constant && rightVal < 0.0 && leftVal  == increasing) decreasing else
		if (rightVar == constant && rightVal > 0.0 && leftVal  == increasing) increasing else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (IntegerDivisionExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		var leftVal  = expr.left .valueFor
		var rightVal = expr.right.valueFor
		if (leftVar  == constant && leftVal  == 0.0) 	  					  constant   else
		if (rightVar == constant && rightVal == 0.0) 	  					  constant   else
		if (leftVar  == constant && rightVar == constant) 					  constant   else
		if (leftVar  == fixed    && rightVar == constant) 					  fixed      else
		if (leftVar  == constant && rightVar == fixed   ) 					  fixed      else
		if (leftVar  == constant && leftVal  < 0.0 && rightVar == increasing) decreasing else
		if (leftVar  == constant && leftVal  > 0.0 && rightVar == increasing) increasing else
		if (rightVar == constant && rightVal < 0.0 && leftVal  == increasing) decreasing else
		if (rightVar == constant && rightVal > 0.0 && leftVal  == increasing) increasing else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (AdditionExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		if (leftVar  == constant && rightVar == constant) 					 								 constant   else
		if (leftVar  == fixed    && rightVar == constant) 					 								 fixed      else
		if (leftVar  == constant && rightVar == fixed   ) 					 								 fixed      else
		if (leftVar  == increasing && (rightVar == constant || rightVar == fixed || rightVar == increasing)) increasing else
		if (rightVar == increasing && (leftVar  == constant || leftVar  == fixed || leftVar  == increasing)) increasing else
		if (leftVar  == decreasing && (rightVar == constant || rightVar == fixed || rightVar == decreasing)) decreasing else
		if (rightVar == decreasing && (leftVar  == constant || leftVar  == fixed || leftVar  == decreasing)) decreasing else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (SubstractionExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		if (leftVar  == constant && rightVar == constant) 					 								 constant   else
		if (leftVar  == fixed    && rightVar == constant) 					 								 fixed      else
		if (leftVar  == constant && rightVar == fixed   ) 					 								 fixed      else
		if (leftVar  == increasing && (rightVar == constant || rightVar == fixed || rightVar == decreasing)) increasing else
		if (leftVar  == decreasing && (rightVar == constant || rightVar == fixed || rightVar == increasing)) decreasing else
		if ((leftVar == constant || leftVar == fixed) && rightVar == increasing)                             decreasing else
		if ((leftVar == constant || leftVar == fixed) && rightVar == decreasing) 							 increasing else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (GreaterThanExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		if (leftVar  == constant && rightVar == constant) constant   else
		if (leftVar  == fixed    && rightVar == constant) fixed      else
		if (leftVar  == constant && rightVar == fixed   ) fixed      else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (GreaterOrEqualExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		if (leftVar  == constant && rightVar == constant) constant   else
		if (leftVar  == fixed    && rightVar == constant) fixed      else
		if (leftVar  == constant && rightVar == fixed   ) fixed      else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (LessOrEqualExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		if (leftVar  == constant && rightVar == constant) constant   else
		if (leftVar  == fixed    && rightVar == constant) fixed      else
		if (leftVar  == constant && rightVar == fixed   ) fixed      else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (LessThanExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		if (leftVar  == constant && rightVar == constant) constant   else
		if (leftVar  == fixed    && rightVar == constant) fixed      else
		if (leftVar  == constant && rightVar == fixed   ) fixed      else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (EqualityExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		if (leftVar  == constant && rightVar == constant) constant   else
		if (leftVar  == fixed    && rightVar == constant) fixed      else
		if (leftVar  == constant && rightVar == fixed   ) fixed      else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (DifferenceExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		if (leftVar  == constant && rightVar == constant) constant   else
		if (leftVar  == fixed    && rightVar == constant) fixed      else
		if (leftVar  == constant && rightVar == fixed   ) fixed      else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (AndExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		if (leftVar  == constant && rightVar == constant) constant   else
		if (leftVar  == fixed    && rightVar == constant) fixed      else
		if (leftVar  == constant && rightVar == fixed   ) fixed      else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (OrExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		if (leftVar  == constant && rightVar == constant) constant   else
		if (leftVar  == fixed    && rightVar == constant) fixed      else
		if (leftVar  == constant && rightVar == fixed   ) fixed      else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (XorExpression expr) {
		var leftVar  = expr.left .variabilityFor
		var rightVar = expr.right.variabilityFor
		if (leftVar  == constant && rightVar == constant) constant   else
		if (leftVar  == fixed    && rightVar == constant) fixed      else
		if (leftVar  == constant && rightVar == fixed   ) fixed      else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (IfExpression expr) {
		var condVar  = expr.condition.variabilityFor
		var thenVar  = expr.then     .variabilityFor
		var elseVar  = expr.^else    .variabilityFor
		if (condVar  == constant && thenVar == constant && elseVar == constant) constant   else
		if (   condVar  == fixed    
			&& (thenVar == constant || thenVar == fixed) 
			&& (elseVar == constant || elseVar == fixed)
		) fixed    else
		normal
	}	
	
	def dispatch Forml0Variability variabilityFor (Boolean item) {
		switch item {
			case item.constant: constant
			case item.fixed: 	fixed
			default: {
				var definition=item.booleanDefinition
				switch definition {
					ExternalBooleanDefinition:	normal
					GlobalBooleanDefinition:	definition.globalValue.expression.variabilityFor
					ItemizedBooleanDefinition:	definition.value.expression.variabilityFor
				}
			}		
		}
	}
	
	def dispatch Forml0Variability variabilityFor (Integer item) {
		if      (item.constant) 				constant
		else if (item.fixed) 	 				fixed
		else if (item.integerDefinition.global) item.integerDefinition.globalValue1.expression.variabilityFor
		else if (item.integerDefinition.value)  item.integerDefinition.globalValue2.expression.variabilityFor
		else 									normal
	}
	
	def dispatch Forml0Variability variabilityFor (Real item) {
		switch item {
			case item.constant: constant
			case item.fixed: 	fixed
			default: {
				var definition=item.realDefinition
				switch definition {
					ExternalRealDefinition:	normal
					GlobalRealDefinition:	definition.globalValue.expression.variabilityFor
					ItemizedRealDefinition:	definition.value.expression.variabilityFor
				}
			}		
		}
	}
}	
