/*
 * generated by Xtext 2.22.0
 */
package edf.validation

import edf.forml0.AdditionExpression
import edf.forml0.AttributeExpression
import edf.forml0.DivisionExpression
import edf.forml0.Expression
import edf.forml0.Integer
import edf.forml0.IntegerDivisionExpression
import edf.forml0.Item
import edf.forml0.NumericLiteral
import edf.forml0.PowerExpression
import edf.forml0.ProductExpression
import edf.forml0.Real
import edf.forml0.Reference
import edf.forml0.Second
import edf.forml0.SubstractionExpression
import edf.forml0.UnaryMinusExpression
import edf.forml0.Tick
import edf.forml0.MyRate
import edf.forml0.Event

import static extension org.eclipse.xtext.EcoreUtil2.*

//=============================================================================
//
//	Value of constant numeric expressions and constant numeric items
// 	Returns 'unknown' if expression or item is not constant or not numeric 
//	(not 0.0, to avoid issues with divisions)
//
//=============================================================================
class Forml0ValueProvider {
	public static val unknown = 1.836168313179e17
	
	def dispatch double valueFor (Expression expr) {
		switch (expr) {
			Second:						1.0
			Tick:						1.0
			UnaryMinusExpression:		if (expr.right.valueFor == unknown) 																unknown									
										else 																								- expr.right.valueFor
			ProductExpression:			if (expr.left.valueFor  == unknown || expr.right.valueFor == unknown)								unknown 
										else 																								expr.left.valueFor * expr.right.valueFor
			DivisionExpression:			if (expr.left.valueFor  == unknown || expr.right.valueFor == unknown || expr.right.valueFor == 0.0)	unknown 
										else 																								expr.left.valueFor / expr.right.valueFor
			IntegerDivisionExpression:	if (expr.left.valueFor  == unknown || expr.right.valueFor == unknown || expr.right.valueFor == 0.0)	unknown 
										else 																								((expr.left.valueFor / expr.right.valueFor) as long) as double
			AdditionExpression:			if (expr.left.valueFor  == unknown || expr.right.valueFor == unknown)								unknown 
										else 																								expr.left.valueFor + expr.right.valueFor
			SubstractionExpression:		if (expr.left.valueFor  == unknown || expr.right.valueFor == unknown)								unknown 
										else 																								expr.left.valueFor - expr.right.valueFor
			default:					unknown
		}
	}
	
	def dispatch double valueFor (NumericLiteral expr) {
		(expr.value.integerValue + Double.parseDouble (expr.value.decimalValue)) * Double.parseDouble ("1." + expr.value.exponent)
	}
	
	def dispatch double valueFor (MyRate expr) {
		var container = expr?.getContainerOfType(typeof(Event))
		if (container === null) 				 unknown
		else if (container.eventDefinition.rate) container.eventDefinition.rateValue.expression.valueFor
		else    								 unknown
	}
	
	def dispatch double valueFor (AttributeExpression expr) {
		// If attribute is previous, value is expr.atom, which must be constant for value to have a meaning
		if (expr.previous) expr.atom.valueFor
		// If attribute is rate, expr.atom must be an event expression
		// Value is unknown except when expr.atom refers to a named event defined by a global rate
		else if (expr.rate) {
			var atom = expr.atom
			if (atom instanceof Event) {
				if (atom.eventDefinition.rate) atom.eventDefinition.rateValue.expression.valueFor else unknown
			} else unknown
		} else unknown
	}
	
	def dispatch double valueFor (Reference expr) {
		var container = expr?.getContainerOfType(typeof(Item))
		if      (expr?.identifier?.name === null) 		 unknown
		else if (container === null) 					 unknown
		else if (container.name == expr.identifier.name) unknown 
		else    										 expr.identifier.valueFor
	}
 	
	def dispatch double valueFor (PowerExpression expr) {
		var double value = 1.0
		var int i
		if (expr.left.valueFor == unknown) return unknown
		for (i = 1; i <= expr.right; i++) value = value*expr.left.valueFor
		expr.negative && value != 0.0 ? 1.0/value : value
	}	
	
	def dispatch double valueFor (Item item) {
		switch item {
			Integer: {
				var definition = item.integerDefinition
				if (item.constant && (definition.global || definition.value) && ! definition.external) 
					definition.globalValue.expression.valueFor
					else unknown
			}
			Real: {
				var definition = item.realDefinition
				if (item.constant && (definition.global || definition.value) && ! definition.external) 
					definition.globalValue.expression.valueFor
					else unknown
			}	
			default:	unknown
		}
	}
}	
	
