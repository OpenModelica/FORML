/*
 * generated by Xtext 2.22.0
 */
package edf.validation

import edf.forml0.AdditionExpression
import edf.forml0.DivisionExpression
import edf.forml0.Expression
import edf.forml0.Integer
import edf.forml0.IntegerDivisionExpression
import edf.forml0.Item
import edf.forml0.NumericLiteral
import edf.forml0.PowerExpression
import edf.forml0.ProductExpression
import edf.forml0.Real
import edf.forml0.Reference
import edf.forml0.SubstractionExpression
import edf.forml0.UnaryMinusExpression
import edf.forml0.AttributeExpression
import edf.forml0.EventLiteral
import static extension org.eclipse.xtext.EcoreUtil2.*

//=============================================================================
//
//	Value of constant numeric expressions and constant numeric items
// 	Returns 'unknown' if expression or item is not constant or not numeric 
//	(not 0.0, to avoid issues with divisions)
//
//=============================================================================
class Forml0ValueProvider {
	public static val unknown = 1.836168313179e17
	
	def dispatch double valueFor (Expression expr) {
		switch (expr) {
			AttributeExpression:		expr.atom.valueFor
			UnaryMinusExpression:		if (expr.right.valueFor == unknown) 																unknown									
										else 																								- expr.right.valueFor
			ProductExpression:			if (expr.left.valueFor  == unknown || expr.right.valueFor == unknown)								unknown 
										else 																								expr.left.valueFor * expr.right.valueFor
			DivisionExpression:			if (expr.left.valueFor  == unknown || expr.right.valueFor == unknown || expr.right.valueFor == 0.0)	unknown 
										else 																								expr.left.valueFor / expr.right.valueFor
			IntegerDivisionExpression:	if (expr.left.valueFor  == unknown || expr.right.valueFor == unknown || expr.right.valueFor == 0.0)	unknown 
										else 																								((expr.left.valueFor / expr.right.valueFor) as long) as double
			AdditionExpression:			if (expr.left.valueFor  == unknown || expr.right.valueFor == unknown)								unknown 
										else 																								expr.left.valueFor + expr.right.valueFor
			SubstractionExpression:		if (expr.left.valueFor  == unknown || expr.right.valueFor == unknown)								unknown 
										else 																								expr.left.valueFor - expr.right.valueFor
			default:					unknown
		}
	}
	
	def dispatch double valueFor (NumericLiteral expr) {
		(expr.value.integerValue + Double.parseDouble (expr.value.decimalValue)) * Double.parseDouble ("1." + expr.value.exponent)
	}
	
	def dispatch double valueFor (Reference expr) {
		var container = expr?.getContainerOfType(typeof(Item))
		if      (expr?.identifier?.name === null) 		 unknown
		else if (container === null) 					 unknown
		else if (container.name == expr.identifier.name) unknown 
		else    										 expr.identifier.valueFor
	}
 	
	def dispatch double valueFor (PowerExpression expr) {
		var double value = 1.0
		var int i
		if (expr.left.valueFor == unknown) return unknown
		for (i = 1; i <= expr.right; i++) value = value*expr.left.valueFor
		expr.negative && value != 0.0 ? 1.0/value : value
	}	
	
	def dispatch double valueFor (Item item) {
		switch item {
			Integer: {
				var definition = item.integerDefinition
				if (item.constant && (definition.global || definition.value) && ! definition.external) 
					definition.globalValue.expression.valueFor
					else unknown
			}
			Real: {
				var definition = item.realDefinition
				if (item.constant && (definition.global || definition.value) && ! definition.external) 
					definition.globalValue.expression.valueFor
					else unknown
			}	
			default:	unknown
		}
	}
}	
	
