/*
 * generated by Xtext 2.22.0
 */
package edf.validation

import edf.forml0.AdditionExpression
import edf.forml0.DivisionExpression
import edf.forml0.Expression
import edf.forml0.Integer
import edf.forml0.IntegerDivisionExpression
import edf.forml0.Item
import edf.forml0.NumericLiteral
import edf.forml0.PowerExpression
import edf.forml0.ProductExpression
import edf.forml0.Real
import edf.forml0.Reference
import edf.forml0.SubstractionExpression
import edf.forml0.UnaryMinusExpression
import edf.forml0.AttributeExpression
import edf.forml0.EventLiteral
import static extension org.eclipse.xtext.EcoreUtil2.*

//=============================================================================
//
//	Value of constant numeric expressions and constant numeric items
// 	Returns 1.0 if expression or item is not constant or not numeric 
//	(not 0.0, to avoid issues with divisions)
//
//=============================================================================
class Forml0ValueProvider {
	def dispatch double valueFor (Expression expr) {
		switch (expr) {
			Reference:					if (expr.getContainerOfType(typeof(Item))?.name == expr?.identifier) 1.0 else expr.identifier.valueFor
			UnaryMinusExpression:		- expr.right.valueFor
			ProductExpression:			expr.left.valueFor * expr.right.valueFor
			DivisionExpression:			expr.left.valueFor / (expr.right.valueFor != 0.0 ? expr.right.valueFor : 1.0)
			IntegerDivisionExpression:	((expr.left.valueFor / (expr.right.valueFor != 0.0 ? expr.right.valueFor : 1.0)) as long) as double
			AdditionExpression:			expr.left.valueFor + expr.right.valueFor
			SubstractionExpression:		expr.left.valueFor - expr.right.valueFor
			default:					1.0
		}
	}
	
	def dispatch double valueFor (NumericLiteral expr) {
		(expr.value.integerValue + Double.parseDouble (expr.value.decimalValue)) * Double.parseDouble ("1." + expr.value.exponent)
	}
	
	def dispatch double valueFor (PowerExpression expr) {
		var double value = 1.0
		var int i
		for (i = 1; i <= expr.right; i++) value = value*expr.left.valueFor
		expr.negative && expr.left.valueFor != 0.0 ? 1.0/value : value
	}	
	
	def dispatch double valueFor (AttributeExpression expr) {
		val atom = expr.atom
		switch atom {
			EventLiteral:	1.0
			default:		atom.valueFor
		}
	}	
	
	def dispatch double valueFor (Item item) {
		switch item {
			Integer: {
				var definition = item.integerDefinition
				if (item.constant && (definition.global || definition.value))  
					definition.globalValue.expression.valueFor
					else 1.0
			}
			Real: {
				var definition = item.realDefinition
				if (item.constant && (definition.global || definition.value)) 
					definition.globalValue.expression.valueFor
					else 1.0
			}	
			default:	1.0
		}
	}
}	
	
