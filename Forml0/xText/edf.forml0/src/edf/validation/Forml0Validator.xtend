/*
 * generated by Xtext 2.22.0
 */
package edf.validation

import com.google.inject.Inject

import edf.forml0.AdditionExpression
import edf.forml0.BecomesExpression
import edf.forml0.Boolean
import edf.forml0.BooleanExpression
import edf.forml0.ChangesExpression
import edf.forml0.Clock
import edf.forml0.DifferenceExpression
import edf.forml0.DivisionExpression
import edf.forml0.DropExpression
import edf.forml0.During
import edf.forml0.EqualityExpression
import edf.forml0.Event
import edf.forml0.EventExpression
import edf.forml0.Expression
import edf.forml0.FirstExpression
import edf.forml0.FollowingExpression
import edf.forml0.Forml0Package
import edf.forml0.FunctionCall
import edf.forml0.GreaterOrEqualExpression
import edf.forml0.GreaterThanExpression
import edf.forml0.IfExpression
import edf.forml0.Integer
import edf.forml0.IntegerDivisionExpression
import edf.forml0.IntegerExpression
import edf.forml0.LeavesExpression
import edf.forml0.LessOrEqualExpression
import edf.forml0.LessThanExpression
import edf.forml0.MyClock
import edf.forml0.MyRate
import edf.forml0.MyValue
import edf.forml0.NumericExpression
import edf.forml0.PowerExpression
import edf.forml0.ProductExpression
import edf.forml0.Property
import edf.forml0.Real
import edf.forml0.SubstractionExpression
import edf.forml0.UnaryMinusExpression
import edf.forml0.WhileExpression
import edf.forml0.WithoutExpression
import edf.forml0.XorExpression
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.validation.Check
import static extension org.eclipse.xtext.EcoreUtil2.*
import edf.forml0.NotExpression
import edf.forml0.AndExpression
import edf.forml0.OrExpression
import edf.forml0.Item
import edf.forml0.Duration
import edf.forml0.BuiltInFunctionCall
import edf.forml0.AttributeExpression
import edf.forml0.PropertyDefinition
import edf.forml0.Ctl
import edf.forml0.Reference
import edf.forml0.PropertyPfd
import edf.forml0.PropertyState
import edf.forml0.PropertyEvent
import edf.forml0.EventDefinition

class Forml0Validator extends AbstractForml0Validator {
	public static val WRONG_TYPE        = "edf.forml0.WrongType"
	public static val WRONG_VARIABILITY = "edf.forml0.WrongVariability"
	public static val WRONG_CONSTRAINT  = "edf.forml0.WrongConstraint"
	public static val WRONG_NUMBER      = "edf.forml0.WrongNumberOfArguments"
	public static val NOT_EXTERNAL	    = "edf.forml0.NotExternal"
	public static val DIVISION_BY_ZERO  = "edf.forml0.DivisionByZero"
	public static val WRONG_DURATION    = "edf.forml0.NegativeOrNullDuration"
	public static val SELF_REFERENCE    = "edf.forml0.SelfReference"
	
	@Inject extension Forml0TypeProvider
	@Inject extension Forml0VariabilityProvider
	@Inject extension Forml0ValueProvider
	@Inject extension Forml0ConstraintCategoryProvider
	
	def private Forml0Type getTypeAndCheckNotNull (Expression expr, EReference reference) {
		if (expr?.typeFor === null) error ("Type undefined", reference, WRONG_TYPE)
		return expr?.typeFor
	}
	
	def private typeCompatibility (Forml0Type actualType, Forml0Type expectedType) {
		// Verifies that actualType is compatible with expectedType
		// Each type is compatible with itself
		// integerType is also compatible with numericType
			actualType == expectedType 
		|| (expectedType == Forml0TypeProvider::numericType && actualType == Forml0TypeProvider::integerType)
	}
	
	def private verifyTypesCompatibility (EReference reference, Expression expr1, Expression expr2) {
		// Verifies that expr1 and expr2 are compatible with one another
		// Each type is compatible with itself
		// integerType is also compatible with numericType
		var type1 = getTypeAndCheckNotNull (expr1, reference)
		var type2 = getTypeAndCheckNotNull (expr2, reference)
			type1 == type2  
		|| (type1 == Forml0TypeProvider::numericType && type2 == Forml0TypeProvider::integerType)
		|| (type1 == Forml0TypeProvider::integerType && type2 == Forml0TypeProvider::numericType)
	}
	
	def private verifyExpectedType (EReference reference, Expression expr, Forml0Type expectedType) {
		// Verifies that expr is compatible with expectedType
		var actualType = getTypeAndCheckNotNull (expr, reference)
		if (!typeCompatibility(actualType, expectedType))
			error ("Expected type " + expectedType.toString + ", but got type " + actualType.toString, reference, WRONG_TYPE)
	}
	
	def private verifyExpected2Types (EReference reference, Expression expr, Forml0Type expectedType1, Forml0Type expectedType2) {
		// Verifies that expr is compatible with expectedType1 or expectedType2
		var actualType = getTypeAndCheckNotNull (expr, reference)
		if (!(typeCompatibility(actualType, expectedType1) || typeCompatibility(actualType, expectedType2))) 
			error ("Expected types " + expectedType1.toString + " or " + expectedType2.toString + ", but got type " + actualType.toString, reference, WRONG_TYPE)
	}

	@Check
	def verifyType (MyRate expr) {
		if (expr.getContainerOfType(typeof(Event)) === null) 
			error ("Expected type Event for item being defined", Forml0Package.Literals::MY_RATE__RATE, WRONG_TYPE)
	}
	
	@Check
	def verifyType (BuiltInFunctionCall expr) {
		switch expr.function {
		 	case 'count': 		verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
									expr.argument, Forml0TypeProvider::eventType)
		 	case 'duration':    verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
									expr.argument, Forml0TypeProvider::booleanType)
		 	case 'inPCount': 	verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
									expr.argument, Forml0TypeProvider::eventType)
		 	case 'inPuration':  verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
									expr.argument, Forml0TypeProvider::booleanType)
		 	case 'inPMax':		 verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
									expr.argument, Forml0TypeProvider::numericType)
		 	case 'inPMin':		verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
									expr.argument, Forml0TypeProvider::numericType)
		 	case 'inTMax':		verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
									expr.argument, Forml0TypeProvider::numericType)
		 	case 'inTMin':		verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
									expr.argument, Forml0TypeProvider::numericType)
		 	case 'probability': verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
									expr.argument, Forml0TypeProvider::eventType)	
		}
	}
	
	@Check
	def verifyType (MyValue expr) {
		if (expr.getContainerOfType(typeof(Boolean)) === null
		&&	expr.getContainerOfType(typeof(Integer)) === null
		&&	expr.getContainerOfType(typeof(Real))    === null)
			error ("Expected type Boolean, Integer or Real for item being defined", Forml0Package.Literals::MY_VALUE__ATTRIBUTE, WRONG_TYPE)
	}
	
	@Check
	def verifyType (MyClock expr) {
		if (expr.getContainerOfType(typeof(Ctl)) !== null)
			error ("Ctl do not have clocks", Forml0Package.Literals::MY_CLOCK__CLOCK, WRONG_TYPE)
	}
	
	@Check
	def verifyType (Clock expr) {
		if (expr.identifier.type == 'Ctl')
			error ("Ctl do not have clocks", Forml0Package.Literals::CLOCK__IDENTIFIER, WRONG_TYPE)
	}
	
	@Check
	def verifyType (PropertyPfd expr) {
		if (expr?.identifier?.name === null)
			error ("Undefined Property name", Forml0Package.Literals::PROPERTY_PFD__IDENTIFIER, SELF_REFERENCE)
		if (expr.getContainerOfType(typeof(Item))?.name == expr?.identifier)  
			error ("Self references are not allowed", Forml0Package.Literals::PROPERTY_PFD__IDENTIFIER, SELF_REFERENCE)
	}
	
	@Check
	def verifyType (PropertyState expr) {
		if (expr?.identifier?.name === null)
			error ("Undefined Property name", Forml0Package.Literals::PROPERTY_STATE__IDENTIFIER, SELF_REFERENCE)
		if (expr.getContainerOfType(typeof(Item))?.name == expr?.identifier)  
			error ("Self references are not allowed", Forml0Package.Literals::PROPERTY_STATE__IDENTIFIER, SELF_REFERENCE)
	}
	
	@Check
	def verifyType (PropertyEvent expr) {
		if (expr?.identifier?.name === null)
			error ("Undefined Property name", Forml0Package.Literals::PROPERTY_EVENT__IDENTIFIER, SELF_REFERENCE)
		if (expr.getContainerOfType(typeof(Item))?.name == expr?.identifier)  
			error ("Self references are not allowed", Forml0Package.Literals::PROPERTY_EVENT__IDENTIFIER, SELF_REFERENCE)
	}
	
	@Check
	def verifyType (Reference expr) {
		if (expr?.identifier?.name === null)
			error ("Undefined name", Forml0Package.Literals::REFERENCE__IDENTIFIER, SELF_REFERENCE)
		if (expr?.getContainerOfType(typeof(Item))?.name == expr?.identifier?.name)  
			error ("Self references are not allowed", Forml0Package.Literals::REFERENCE__IDENTIFIER, SELF_REFERENCE)
	}
	
	@Check
	def verifyType (FunctionCall expr) {
		if (expr?.function?.name === null)
			error ("Undefined function name", Forml0Package.Literals::FUNCTION_CALL__FUNCTION, SELF_REFERENCE)
		if (expr.getContainerOfType(typeof(Item))?.name == expr?.function.name)  
			error ("Self references are not allowed", Forml0Package.Literals::FUNCTION_CALL__FUNCTION, SELF_REFERENCE)
		if (expr.function.type != 'Boolean'
		&&	expr.function.type != 'Integer'
		&&	expr.function.type != 'Real'
		&&	expr.function.type != 'Event')
			error ("Expected type Boolean, Integer, Real or Event, instead got type " + expr.function.type, Forml0Package.Literals::FUNCTION_CALL__FUNCTION, WRONG_TYPE)
		var parameters = functionParameters (expr.function)
		var arguments  = expr.arguments
		if (parameters.size != arguments.size)
			error ("Expected " + parameters.size + " arguments, but got " + arguments.size + " instead", Forml0Package.Literals::FUNCTION_CALL__ARGUMENTS, WRONG_NUMBER)
		var int i
		for (i=0; i < parameters.size; i++) {
			var expected = switch parameters.get(i).type {
				case 'Boolean':		Forml0TypeProvider::booleanType
				case 'Integer':		Forml0TypeProvider::integerType
				case 'Real':		Forml0TypeProvider::numericType
				case 'Event':		Forml0TypeProvider::eventType
			}
			verifyExpectedType (Forml0Package.Literals::FUNCTION_CALL__ARGUMENTS,
				arguments.get(i), expected)
			// How could we more precisely identify the incorrect argument in the list
			if (parameters.get(i).constant && arguments.get(i).variabilityFor != Forml0VariabilityProvider::constant)
				error ("Argument " + i + " should be constant but is " + arguments.get(i).variabilityFor, Forml0Package.Literals::FUNCTION_CALL__ARGUMENTS, WRONG_VARIABILITY)
			if (parameters.get(i).fixed && !(arguments.get(i).variabilityFor == Forml0VariabilityProvider::constant || arguments.get(i).variabilityFor == Forml0VariabilityProvider::fixed))
				error ("Argument " + i + " should be fixed but is " + arguments.get(i).variabilityFor, Forml0Package.Literals::FUNCTION_CALL__ARGUMENTS, WRONG_VARIABILITY)
		}
	}
	
	def functionParameters (Item item) {
		if      (item.^boolean !== null)	(item as Boolean).parameters
		else if (item.integer  !== null)	(item as Integer).parameters
		else if (item.real     !== null)	(item as Real   ).parameters
		else if (item.event    !== null)	(item as Event  ).parameters
		else null
	}
		
	@Check
	def verifyType (AttributeExpression expr) {
		if (expr.rate) verifyExpectedType (Forml0Package.Literals::ATTRIBUTE_EXPRESSION__ATOM, 
				expr.atom, Forml0TypeProvider::eventType)
		if (expr.previous) verifyExpected2Types (Forml0Package.Literals::ATTRIBUTE_EXPRESSION__ATOM, 
				expr.atom, Forml0TypeProvider::booleanType,
			           	   Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (PowerExpression expr) {
		verifyExpectedType (Forml0Package.Literals::POWER_EXPRESSION__LEFT,
			expr.left, Forml0TypeProvider::numericType)
		if (expr.negative && expr.left.variabilityFor == Forml0VariabilityProvider::constant && expr.left.valueFor == 0.0)
			error ("Division by zero since value is constant 0 and exponent is negative", Forml0Package.Literals::POWER_EXPRESSION__LEFT, DIVISION_BY_ZERO)
	}
	
	@Check
	def verifyType (UnaryMinusExpression expr) {
		verifyExpectedType (Forml0Package.Literals::UNARY_MINUS_EXPRESSION__RIGHT,
			expr.right, Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (NotExpression expr) {
		verifyExpectedType (Forml0Package.Literals::NOT_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::booleanType)
	}
	
	@Check
	def verifyType (ProductExpression expr) {
		verifyExpectedType (Forml0Package.Literals::PRODUCT_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::numericType) 
		verifyExpectedType (Forml0Package.Literals::PRODUCT_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (DivisionExpression expr) {
		verifyExpectedType (Forml0Package.Literals::DIVISION_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::numericType)
		verifyExpectedType (Forml0Package.Literals::DIVISION_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::numericType)
		if (expr.right.variabilityFor == Forml0VariabilityProvider::constant && expr.right.valueFor == 0.0)
			error ("Division by zero since right operand is constant 0", Forml0Package.Literals::DIVISION_EXPRESSION__RIGHT, DIVISION_BY_ZERO)
	}
	
	@Check
	def verifyType (IntegerDivisionExpression expr) {
		verifyExpectedType (Forml0Package.Literals::INTEGER_DIVISION_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::numericType)
		verifyExpectedType (Forml0Package.Literals::INTEGER_DIVISION_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (AdditionExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::ADDITION_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::numericType,
			           Forml0TypeProvider::eventType)
		verifyExpectedType (Forml0Package.Literals::ADDITION_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (SubstractionExpression expr) {
		verifyExpectedType (Forml0Package.Literals::SUBSTRACTION_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::numericType)
		verifyExpectedType (Forml0Package.Literals::SUBSTRACTION_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (WithoutExpression expr) {
		verifyExpectedType (Forml0Package.Literals::WITHOUT_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::eventType)
		verifyExpectedType (Forml0Package.Literals::WITHOUT_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::eventType)
	}
	
	@Check
	def verifyType (FollowingExpression expr) {
		verifyExpectedType (Forml0Package.Literals::FOLLOWING_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::eventType)
		verifyExpectedType (Forml0Package.Literals::FOLLOWING_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::eventType)
	}
	
	@Check
	def verifyType (EqualityExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::EQUALITY_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::booleanType,
					   Forml0TypeProvider::numericType)
		verifyExpected2Types (Forml0Package.Literals::EQUALITY_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::booleanType,
						Forml0TypeProvider::numericType)
		verifyTypesCompatibility (Forml0Package.Literals::EQUALITY_EXPRESSION__RIGHT, 
			expr.left, expr.right)
	}
	
	@Check
	def verifyType (DifferenceExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::DIFFERENCE_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::booleanType,
					   Forml0TypeProvider::numericType)
		verifyExpected2Types (Forml0Package.Literals::DIFFERENCE_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::booleanType,
						Forml0TypeProvider::numericType)
		verifyTypesCompatibility (Forml0Package.Literals::DIFFERENCE_EXPRESSION__RIGHT, 
			expr.left, expr.right)
	}
	
	@Check
	def verifyType (LessThanExpression expr) {
		verifyExpectedType (Forml0Package.Literals::LESS_THAN_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::numericType)
		verifyExpectedType (Forml0Package.Literals::LESS_THAN_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (LessOrEqualExpression expr) {
		verifyExpectedType (Forml0Package.Literals::LESS_OR_EQUAL_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::numericType)
		verifyExpectedType (Forml0Package.Literals::LESS_OR_EQUAL_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (GreaterThanExpression expr) {
		verifyExpectedType (Forml0Package.Literals::GREATER_THAN_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::numericType)
		verifyExpectedType (Forml0Package.Literals::GREATER_THAN_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (GreaterOrEqualExpression expr) {
		verifyExpectedType (Forml0Package.Literals::GREATER_OR_EQUAL_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::numericType)
		verifyExpectedType (Forml0Package.Literals::GREATER_OR_EQUAL_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (AndExpression expr) {
		verifyExpectedType (Forml0Package.Literals::AND_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::booleanType)
		verifyExpectedType (Forml0Package.Literals::AND_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::booleanType)
	}
	
	@Check
	def verifyType (WhileExpression expr) {
		verifyExpectedType (Forml0Package.Literals::WHILE_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::eventType)
		verifyExpected2Types (Forml0Package.Literals::WHILE_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::booleanType,
			            Forml0TypeProvider::eventType)
	}
	
	@Check
	def verifyType (OrExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::OR_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::booleanType,
					   Forml0TypeProvider::eventType)
		verifyExpected2Types (Forml0Package.Literals::OR_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::booleanType,
						Forml0TypeProvider::eventType)
		verifyTypesCompatibility (Forml0Package.Literals::OR_EXPRESSION__RIGHT, 
			expr.left, expr.right)
	}
	
	@Check
	def verifyType (XorExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::XOR_EXPRESSION__LEFT, 
			expr.left, Forml0TypeProvider::booleanType,
					   Forml0TypeProvider::eventType)
		verifyExpected2Types (Forml0Package.Literals::XOR_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::booleanType,
						Forml0TypeProvider::eventType)
		verifyTypesCompatibility (Forml0Package.Literals::XOR_EXPRESSION__RIGHT, 
			expr.left, expr.right)
	}
	
	@Check
	def verifyType (IfExpression expr) {
		verifyTypesCompatibility (Forml0Package.Literals::IF_EXPRESSION__ELSE, 
			expr.then, expr.^else)
	}
	
	@Check
	def verifyType (ChangesExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::CHANGES_EXPRESSION__EXPRESSION, 
			expr.expression, Forml0TypeProvider::booleanType,
					         Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (BecomesExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::BECOMES_EXPRESSION__EXPRESSION, 
			expr.expression, Forml0TypeProvider::booleanType,
					         Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (LeavesExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::LEAVES_EXPRESSION__EXPRESSION, 
			expr.expression, Forml0TypeProvider::booleanType,
					         Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (FirstExpression expr) {
		verifyExpectedType (Forml0Package.Literals::FIRST_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::eventType)
	}
	
	@Check
	def verifyType (DropExpression expr) {
		verifyExpectedType (Forml0Package.Literals::DROP_EXPRESSION__RIGHT, 
			expr.right, Forml0TypeProvider::eventType)
	}
	
	@Check
	def verifyType (EventExpression expr) {
		verifyExpectedType (Forml0Package.Literals::EVENT_EXPRESSION__EXPRESSION, 
			expr.expression, Forml0TypeProvider::eventType)
	}
	
	@Check
	def verifyType (NumericExpression expr) {
		verifyExpectedType (Forml0Package.Literals::NUMERIC_EXPRESSION__EXPRESSION, 
			expr.expression, Forml0TypeProvider::numericType)
	}
	
	@Check
	def verifyType (IntegerExpression expr) {
		verifyExpectedType (Forml0Package.Literals::INTEGER_EXPRESSION__EXPRESSION, 
			expr.expression, Forml0TypeProvider::integerType)
	}
	
	@Check
	def verifyType (BooleanExpression expr) {
		verifyExpectedType (Forml0Package.Literals::BOOLEAN_EXPRESSION__EXPRESSION, 
			expr.expression, Forml0TypeProvider::booleanType)
	}
	
	@Check
	def verifyType (During expr) {
		verifyExpected2Types (Forml0Package.Literals::DURING__CONDITION, 
			expr.condition, Forml0TypeProvider::booleanType,
						    Forml0TypeProvider::ctlType)
	}
	
	def private Forml0Variability getItemVariabilityAndCheckNotNull (Item item, EReference reference) {
		if (item                 === null) error ("Item undefined", reference, WRONG_VARIABILITY)
		if (item?.variabilityFor === null) error ("Variability undefined", reference, WRONG_VARIABILITY)
		return item?.variabilityFor
	}

	@Check
	def verifyVariability (Boolean item) {
		var variability = getItemVariabilityAndCheckNotNull (item, Forml0Package.Literals::BOOLEAN__BOOLEAN_DEFINITION)
 		if (item?.constant && variability != Forml0VariabilityProvider::constant) 
 			error ("Expected a constant expression, but got a " + variability.toString + " expression ",
 				  Forml0Package.Literals::BOOLEAN__BOOLEAN_DEFINITION, WRONG_VARIABILITY)
 		else if (item?.fixed && variability != Forml0VariabilityProvider::constant && variability != Forml0VariabilityProvider::fixed)
 			error ("Expected a fixed expression, but got a " + variability.toString + " expression ",
 				  Forml0Package.Literals::BOOLEAN__BOOLEAN_DEFINITION, WRONG_VARIABILITY)
	}
		
	@Check
	def verifyExternal (Boolean item) {
 		if (item?.parameters?.size > 0 && !item?.booleanDefinition?.external)    
 			error ("In Form-L0, Boolean definitions with parameters other than time must be external", Forml0Package.Literals::BOOLEAN__BOOLEAN_DEFINITION, NOT_EXTERNAL)
	}
		
	@Check
	def verifyVariability (Integer item) {
		var variability = getItemVariabilityAndCheckNotNull (item, Forml0Package.Literals::INTEGER__INTEGER_DEFINITION)
 		if (item?.constant && variability != Forml0VariabilityProvider::constant) 
 			error ("Expected a constant expression, but got a " + variability.toString + " expression ",
 				  Forml0Package.Literals::INTEGER__INTEGER_DEFINITION, WRONG_VARIABILITY)
 		else if (item?.fixed && variability != Forml0VariabilityProvider::constant && variability != Forml0VariabilityProvider::fixed)
 			error ("Expected a fixed expression, but got a " + variability.toString + " expression ",
 				  Forml0Package.Literals::INTEGER__INTEGER_DEFINITION, WRONG_VARIABILITY)
	}
		
	@Check
	def verifyExternal (Integer item) {
 		if (item?.parameters?.size > 0 && !item?.integerDefinition?.external)    
 			error ("In Form-L0, Integer definitions with parameters other than time must be external", Forml0Package.Literals::INTEGER__INTEGER_DEFINITION, NOT_EXTERNAL)
	}
		
	@Check
	def verifyVariability (Real item) {
		var variability = getItemVariabilityAndCheckNotNull (item, Forml0Package.Literals::REAL__REAL_DEFINITION)
 		if (item?.constant && variability != Forml0VariabilityProvider::constant) 
 			error ("Expected a constant expression, but got a " + variability.toString + " expression ",
 				  Forml0Package.Literals::REAL__REAL_DEFINITION, WRONG_VARIABILITY)
 		else if (item?.fixed && variability != Forml0VariabilityProvider::constant && variability != Forml0VariabilityProvider::fixed)
 			error ("Expected a fixed expression, but got a " + variability.toString + " expression ",
 				  Forml0Package.Literals::REAL__REAL_DEFINITION, WRONG_VARIABILITY)
	}
	
	@Check
	def verifyExternal (Real item) {
 		if (item?.parameters?.size > 0 && !item.realDefinition?.external)    
 			error ("In Form-L0, Real definitions with parameters other than time must be external", Forml0Package.Literals::REAL__REAL_DEFINITION, NOT_EXTERNAL)
	}
		
	@Check
	def verifyExternal (Event item) {
 		if (item?.parameters?.size > 0 && !item?.eventDefinition?.external)    
 			error ("In Form-L0, Event definitions with parameters other than time must be external", Forml0Package.Literals::EVENT__EVENT_DEFINITION, NOT_EXTERNAL)
	}
		
	@Check
	def verifyExternal (EventDefinition definition) {
		var variability = definition?.rateValue?.variabilityFor
 		if (definition?.rate && variability != Forml0VariabilityProvider::constant)   
 			error ("Set event rates must be constant, this one is " + variability, Forml0Package.Literals::EVENT__EVENT_DEFINITION, NOT_EXTERNAL)
	}
		
	@Check
	def verifyConstraintType (PropertyDefinition p) {
		if (p?.achieve && p.constraint.expression.constraintCategoryFor == Forml0ConstraintCategoryProvider::notELSConstraint)
			error ("The constraint is not suitable for an 'achieve' Property", Forml0Package.Literals::PROPERTY_DEFINITION__CONSTRAINT, WRONG_CONSTRAINT)
	}
	
	@Check
	def verifyDuration (Duration d) {
		if (d.value.expression.variabilityFor == Forml0VariabilityProvider::constant && d.value.expression.valueFor <= 0.0)
			error ("Constant durations must be strictly positive, and this one is " + d.value.expression.valueFor, Forml0Package.Literals::DURATION__VALUE, WRONG_DURATION)
		if (d.ticks) verifyExpectedType (Forml0Package.Literals::DURATION__VALUE, 
			d.value.expression, Forml0TypeProvider::integerType)
		var item = d.getContainerOfType(typeof(Item))
		if (d.ticks && item === null) 
			error ("Use of ticks without a containing item", Forml0Package.Literals::DURATION__VALUE, WRONG_DURATION)
		if (item.^boolean !== null) {
			if (!(item.^boolean as Boolean).booleanDefinition.clock) 
				error ("Use of ticks when containing Boolean does not have a clock ", Forml0Package.Literals::DURATION__VALUE, WRONG_DURATION)
		}	
		if (item.integer !== null) {
			if (!(item.integer as Integer).integerDefinition.clock) 
				error ("Use of ticks when containing Integer does not have a clock ", Forml0Package.Literals::DURATION__VALUE, WRONG_DURATION)
		}
		if (item.real !== null) {
			if (!(item.real as Real).realDefinition.clock) 
				error ("Use of ticks when containing Real does not have a clock ", Forml0Package.Literals::DURATION__VALUE, WRONG_DURATION)
		}
		if (item.event !== null) {
			if (!(item.event as Event).eventDefinition.clock) 
				error ("Use of ticks when containing Event does not have a clock ", Forml0Package.Literals::DURATION__VALUE, WRONG_DURATION)
		}
		if (item.property !== null) {
			if (!(item.^property as Property).propertyDefinition.clock) 
				error ("Use of ticks when containing Property does not have a clock ", Forml0Package.Literals::DURATION__VALUE, WRONG_DURATION)
		}
	}
	
}	

	