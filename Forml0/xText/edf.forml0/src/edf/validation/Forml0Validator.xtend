/*
 * generated by Xtext 2.22.0
 */
package edf.validation

import com.google.inject.Inject

import edf.forml0.AdditionExpression
import edf.forml0.BecomesExpression
import edf.forml0.Boolean
import edf.forml0.BooleanExpression
import edf.forml0.ChangesExpression
import edf.forml0.Clock
import edf.forml0.DifferenceExpression
import edf.forml0.DivisionExpression
import edf.forml0.DropExpression
import edf.forml0.During
import edf.forml0.EqualityExpression
import edf.forml0.Event
import edf.forml0.EventExpression
import edf.forml0.Expression
import edf.forml0.FirstExpression
import edf.forml0.FollowingExpression
import edf.forml0.Forml0Package
import edf.forml0.FunctionCall
import edf.forml0.GreaterOrEqualExpression
import edf.forml0.GreaterThanExpression
import edf.forml0.IfExpression
import edf.forml0.Integer
import edf.forml0.IntegerDivisionExpression
import edf.forml0.IntegerExpression
import edf.forml0.LeavesExpression
import edf.forml0.LessOrEqualExpression
import edf.forml0.LessThanExpression
import edf.forml0.MyClock
import edf.forml0.MyRate
import edf.forml0.MyValue
import edf.forml0.NumericExpression
import edf.forml0.PowerExpression
import edf.forml0.ProductExpression
import edf.forml0.Property
import edf.forml0.Real
import edf.forml0.SubstractionExpression
import edf.forml0.UnaryMinusExpression
import edf.forml0.WhileExpression
import edf.forml0.WithoutExpression
import edf.forml0.XorExpression
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.validation.Check
import static extension org.eclipse.xtext.EcoreUtil2.*
import edf.forml0.NotExpression
import edf.forml0.AndExpression
import edf.forml0.OrExpression
import edf.forml0.Item
import edf.forml0.BuiltInFunctionCall
import edf.forml0.AttributeExpression
import edf.forml0.PropertyDefinition
import edf.forml0.Ctl
import edf.forml0.Reference
import edf.forml0.PropertyPfd
import edf.forml0.PropertyState
import edf.forml0.PropertyEvent
import edf.forml0.Tick
import edf.forml0.ClockTime
import edf.forml0.InPClockTime
import edf.forml0.MyDerivative
import edf.forml0.DurationExpression
import edf.forml0.RateExpression
import edf.forml0.BooleanStatement
import edf.forml0.IntegerStatement
import edf.forml0.NumericStatement
import edf.forml0.EventStatement
import edf.forml0.DiscreteRateExpression

class Forml0Validator extends AbstractForml0Validator {
	public static val WRONG_TYPE        = "edf.forml0.WrongType"
	public static val WRONG_QUANTITY    = "edf.forml0.WrongQuantity"
	public static val WRONG_VARIABILITY = "edf.forml0.WrongVariability"
	public static val WRONG_CONSTRAINT  = "edf.forml0.WrongConstraint"
	public static val WRONG_NUMBER      = "edf.forml0.WrongNumberOfArguments"
	public static val NOT_EXTERNAL	    = "edf.forml0.NotExternal"
	public static val DIVISION_BY_ZERO  = "edf.forml0.DivisionByZero"
	public static val WRONG_DURATION    = "edf.forml0.NegativeOrNullDuration"
	public static val WRONG_RATE        = "edf.forml0.NegativeOrNullRate"
	public static val SELF_REFERENCE    = "edf.forml0.SelfReference"
	public static val NO_CLOCK          = "edf.forml0.NoClock"
	
	static val booleanType 		= Forml0TypeProvider::booleanType
	static val integerType 		= Forml0TypeProvider::integerType
	static val numericType 		= Forml0TypeProvider::numericType
	static val eventType   		= Forml0TypeProvider::eventType
	static val ctlType     		= Forml0TypeProvider::ctlType
	static val unknownType     	= Forml0TypeProvider::unknownType
	static val constant    		= Forml0VariabilityProvider::constant
	static val fixed            = Forml0VariabilityProvider::fixed
	static val scalar           = Forml0QuantityProvider::scalar
	static val time             = Forml0QuantityProvider::time
	static val tick             = Forml0QuantityProvider::tick
	static val rate             = Forml0QuantityProvider::rate
	static val notELSConstraint = Forml0ConstraintCategoryProvider::notELSConstraint
	
	@Inject extension Forml0TypeProvider
	@Inject extension Forml0VariabilityProvider
	@Inject extension Forml0ValueProvider
	@Inject extension Forml0ConstraintCategoryProvider
	@Inject extension Forml0QuantityProvider
	
	def private Forml0Type getTypeAndCheckNotNull (Expression expr, EReference reference) {
		if (expr?.typeFor === null) error ("Undefined identifier", reference, WRONG_TYPE)
		return expr?.typeFor
	}
	
	def private typeCompatibility (Forml0Type actualType, Forml0Type expectedType) {
		// Verifies that actualType is compatible with expectedType
		// Each type is compatible with itself
		// integerType is also compatible with numericType
			actualType == expectedType 
		|| (expectedType == numericType && actualType == integerType)
	}
	
	def private verifyTypesCompatibility (EReference reference, Expression expr1, Expression expr2) {
		// Verifies that expr1 and expr2 are compatible with one another
		// Each type is compatible with itself
		// integerType is also compatible with numericType
		var type1 = getTypeAndCheckNotNull (expr1, reference)
		var type2 = getTypeAndCheckNotNull (expr2, reference)
			type1 == type2  
		|| (type1 == numericType && type2 == integerType)
		|| (type1 == integerType && type2 == numericType)
	}
	
	def private verifyExpectedType (EReference reference, Expression expr, Forml0Type expectedType) {
		// Verifies that expr is compatible with expectedType
		var actualType = getTypeAndCheckNotNull (expr, reference)
		if (!typeCompatibility(actualType, expectedType) && expectedType.toString == "Integer" && actualType.toString == "Integer or Real")
			error ("Expected type " + expectedType.toString + ", but got type Real" , reference, WRONG_TYPE)
		else if (!typeCompatibility(actualType, expectedType))
			error ("Expected type " + expectedType.toString + ", but got type " + actualType.toString, reference, WRONG_TYPE)
	}
	
	def private verifyExpected2Types (EReference reference, Expression expr, Forml0Type expectedType1, Forml0Type expectedType2) {
		// Verifies that expr is compatible with expectedType1 or expectedType2
		var actualType = getTypeAndCheckNotNull (expr, reference)
		if (!(typeCompatibility(actualType, expectedType1) || typeCompatibility(actualType, expectedType2))) 
			error ("Expected types " + expectedType1.toString + " or " + expectedType2.toString + ", but got type " + actualType.toString, reference, WRONG_TYPE)
	}

	@Check
	def verifyClock (Tick expr) {
		var container = expr.getContainerOfType(typeof(Item))
		var boolean hasClock
		switch container {
			Boolean:	hasClock = container.booleanDefinition.clock
			Integer:	hasClock = container.integerDefinition.clock
			Real:		hasClock = container.realDefinition.clock
			Event:		hasClock = container.eventDefinition.clock
			Property:	hasClock = container.propertyDefinition.clock
			Ctl:		hasClock = container.ctlDefinition.clock
		}	
		if (!hasClock) error ("The item being defined does not have a clock", Forml0Package.Literals::TICK__UNIT, NO_CLOCK)
	}
	
	@Check
	def verifyClock (ClockTime expr) {
		var container = expr.getContainerOfType(typeof(Item))
		var boolean hasClock
		switch container {
			Boolean:	hasClock = container.booleanDefinition.clock
			Integer:	hasClock = container.integerDefinition.clock
			Real:		hasClock = container.realDefinition.clock
			Event:		hasClock = container.eventDefinition.clock
			Property:	hasClock = container.propertyDefinition.clock
			Ctl:		hasClock = container.ctlDefinition.clock
		}	
		if (!hasClock) error ("The item being defined does not have a clock", Forml0Package.Literals::CLOCK_TIME__TIME, NO_CLOCK)
	}
	
	@Check
	def verifyClock (InPClockTime expr) {
		var container = expr.getContainerOfType(typeof(Item))
		var boolean hasClock
		switch container {
			Boolean:	hasClock = container.booleanDefinition.clock
			Integer:	hasClock = container.integerDefinition.clock
			Real:		hasClock = container.realDefinition.clock
			Event:		hasClock = container.eventDefinition.clock
			Property:	hasClock = container.propertyDefinition.clock
			Ctl:		hasClock = container.ctlDefinition.clock
		}	
		if (!hasClock) error ("The item being defined does not have a clock", Forml0Package.Literals::IN_PCLOCK_TIME__TIME, NO_CLOCK)
	}
	
	@Check
	def verifyType (MyDerivative expr) {
		var container = expr.getContainerOfType(typeof(Real))
		if (container === null && expr.derivative) 
			error ("Item being defined should be a Real", Forml0Package.Literals::MY_DERIVATIVE__DERIVATIVE, WRONG_TYPE)
		if (container === null && expr.integral) 
			error ("Item being defined should be a Real", Forml0Package.Literals::MY_DERIVATIVE__INTEGRAL, WRONG_TYPE)
	}
	
	@Check
	def verifyType (MyRate expr) {
		var container = expr.getContainerOfType(typeof(Event))
		if (container === null) 
			error ("Item being defined should be an Event", Forml0Package.Literals::MY_RATE__RATE, WRONG_TYPE)
	}
	
	@Check
	def verifyType (BuiltInFunctionCall expr) {
		switch expr.function {
		 	case 'count': 				verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
											expr.argument, eventType)
		 	case 'duration':    		verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
											expr.argument, booleanType)
		 	case 'clockDuration':   	verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
											expr.argument, booleanType)
		 	case 'inPCount': 			verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
											expr.argument, eventType)
		 	case 'inPuration':  		verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
											expr.argument, booleanType)
		 	case 'inPClockDuration':    verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
											expr.argument, booleanType)
		 	case 'inPMax':		 		verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
											expr.argument, numericType)
		 	case 'inPMin':				verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
											expr.argument, numericType)
		 	case 'inTMax':				verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
											expr.argument, numericType)
		 	case 'inTMin':				verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
											expr.argument, numericType)
		 	case 'probability': 		verifyExpectedType (Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT,
											expr.argument, eventType)	
		}
	}
	
	@Check
	def verifyClock (BuiltInFunctionCall expr) {
		if (expr.function == 'clockDuration' || expr.function == 'inPClockDuration') {
			var container = expr.getContainerOfType(typeof(Item))
			var boolean hasClock
			switch container {
				Boolean:	hasClock = container.booleanDefinition.clock
				Integer:	hasClock = container.integerDefinition.clock
				Real:		hasClock = container.realDefinition.clock
				Event:		hasClock = container.eventDefinition.clock
				Property:	hasClock = container.propertyDefinition.clock
				Ctl:		hasClock = container.ctlDefinition.clock
			}	
			if (!hasClock) error ("The item being defined does not have a clock", Forml0Package.Literals::BUILT_IN_FUNCTION_CALL__ARGUMENT, NO_CLOCK)
		}
	}
	
	@Check
	def verifyType (MyValue expr) {
		if (expr.getContainerOfType(typeof(Boolean)) === null
		&&	expr.getContainerOfType(typeof(Integer)) === null
		&&	expr.getContainerOfType(typeof(Real))    === null)
			error ("Expected type Boolean, Integer or Real for item being defined", Forml0Package.Literals::MY_VALUE__ATTRIBUTE, WRONG_TYPE)
	}
	
	@Check
	def verifyClock (MyClock expr) {
		var container = expr.getContainerOfType(typeof(Item))
		var boolean hasClock
		switch container {
			Boolean:	hasClock = container.booleanDefinition.clock
			Integer:	hasClock = container.integerDefinition.clock
			Real:		hasClock = container.realDefinition.clock
			Event:		hasClock = container.eventDefinition.clock
			Property:	hasClock = container.propertyDefinition.clock
			Ctl:		hasClock = container.ctlDefinition.clock
		}	
		if (!hasClock)	error ("The item being defined does not have a clock", Forml0Package.Literals::MY_CLOCK__CLOCK, NO_CLOCK)
	}
	
	@Check
	def verifyType (Clock expr) {
		if (expr.identifier.type == 'Ctl')
			error ("Ctl do not have clocks", Forml0Package.Literals::CLOCK__IDENTIFIER, WRONG_TYPE)
	}
	
	@Check
	def verifyType (PropertyPfd expr) {
		if (expr?.identifier?.name === null)
			error ("Undefined Property name", Forml0Package.Literals::PROPERTY_PFD__IDENTIFIER, SELF_REFERENCE)
		if (expr.getContainerOfType(typeof(Item))?.name == expr?.identifier)  
			error ("Self references are not allowed", Forml0Package.Literals::PROPERTY_PFD__IDENTIFIER, SELF_REFERENCE)
	}
	
	@Check
	def verifyType (PropertyState expr) {
		if (expr?.identifier?.name === null)
			error ("Undefined Property name", Forml0Package.Literals::PROPERTY_STATE__IDENTIFIER, SELF_REFERENCE)
		if (expr.getContainerOfType(typeof(Item))?.name == expr?.identifier)  
			error ("Self references are not allowed", Forml0Package.Literals::PROPERTY_STATE__IDENTIFIER, SELF_REFERENCE)
	}
	
	@Check
	def verifyType (PropertyEvent expr) {
		if (expr?.identifier?.name === null)
			error ("Undefined Property name", Forml0Package.Literals::PROPERTY_EVENT__IDENTIFIER, SELF_REFERENCE)
		if (expr.getContainerOfType(typeof(Item))?.name == expr?.identifier)  
			error ("Self references are not allowed", Forml0Package.Literals::PROPERTY_EVENT__IDENTIFIER, SELF_REFERENCE)
	}
	
	@Check
	def verifyType (Reference expr) {
		if (expr?.identifier?.name === null)
			error ("Undefined name", Forml0Package.Literals::REFERENCE__IDENTIFIER, SELF_REFERENCE)
		if (expr?.getContainerOfType(typeof(Item))?.name == expr?.identifier?.name)  
			error ("Self references are not allowed", Forml0Package.Literals::REFERENCE__IDENTIFIER, SELF_REFERENCE)
	}
	
	@Check
	def verifyType (FunctionCall expr) {
		if (expr?.function?.name === null)
			error ("Undefined function name", Forml0Package.Literals::FUNCTION_CALL__FUNCTION, SELF_REFERENCE)
		if (expr.getContainerOfType(typeof(Item))?.name == expr?.function.name)  
			error ("Self references are not allowed", Forml0Package.Literals::FUNCTION_CALL__FUNCTION, SELF_REFERENCE)
		if (expr.function.type != 'Boolean'
		&&	expr.function.type != 'Integer'
		&&	expr.function.type != 'Real'
		&&	expr.function.type != 'Event')
			error ("Expected type Boolean, Integer, Real or Event, instead got type " + expr.function.type, Forml0Package.Literals::FUNCTION_CALL__FUNCTION, WRONG_TYPE)
		var parameters = functionParameters (expr.function)
		var arguments  = expr.arguments
		if (parameters.size != arguments.size)
			error ("Expected " + parameters.size + " arguments, but got " + arguments.size + " instead", Forml0Package.Literals::FUNCTION_CALL__ARGUMENTS, WRONG_NUMBER)
		var int i
		for (i=0; i < parameters.size; i++) {
			var expected = switch parameters.get(i).type {
				case 'Boolean':		booleanType
				case 'Integer':		integerType
				case 'Real':		numericType
				case 'Event':		eventType
			}
			verifyExpectedType (Forml0Package.Literals::FUNCTION_CALL__ARGUMENTS,
				arguments.get(i), expected)
			// How could we more precisely identify the incorrect argument in the list
			if (parameters.get(i).constant && arguments.get(i).variabilityFor != constant)
				error ("Argument " + i + " should be constant but is " + arguments.get(i).variabilityFor, Forml0Package.Literals::FUNCTION_CALL__ARGUMENTS, WRONG_VARIABILITY)
			if (parameters.get(i).fixed && !(arguments.get(i).variabilityFor == constant || arguments.get(i).variabilityFor == fixed))
				error ("Argument " + i + " should be fixed but is " + arguments.get(i).variabilityFor, Forml0Package.Literals::FUNCTION_CALL__ARGUMENTS, WRONG_VARIABILITY)
		}
	}
	
	def functionParameters (Item item) {
		if      (item.^boolean !== null)	(item as Boolean).parameters
		else if (item.integer  !== null)	(item as Integer).parameters
		else if (item.real     !== null)	(item as Real   ).parameters
		else if (item.event    !== null)	(item as Event  ).parameters
		else null
	}
		
	@Check
	def verifyType (AttributeExpression expr) {
		if (expr.rate) verifyExpectedType (Forml0Package.Literals::ATTRIBUTE_EXPRESSION__ATOM, 
				expr.atom, eventType)
		if (expr.previous) verifyExpected2Types (Forml0Package.Literals::ATTRIBUTE_EXPRESSION__ATOM, 
				expr.atom, booleanType,
			           	   numericType)
		if (expr.derivative || expr.integral) {
			var actualType = getTypeAndCheckNotNull (expr.atom, Forml0Package.Literals::ATTRIBUTE_EXPRESSION__ATOM)
			if (actualType != numericType)
				error ("Expected a Real, but got type " + actualType.toString, Forml0Package.Literals::ATTRIBUTE_EXPRESSION__ATOM, WRONG_TYPE)			
		}
	}
	
	@Check
	def verifyType (PowerExpression expr) {
		verifyExpectedType (Forml0Package.Literals::POWER_EXPRESSION__LEFT,
			expr.left, numericType)
		if (expr.negative && expr.left.variabilityFor == constant && expr.left.valueFor == 0.0)
			error ("Division by zero since value is constant 0 and exponent is negative", Forml0Package.Literals::POWER_EXPRESSION__LEFT, DIVISION_BY_ZERO)
	}
	
	@Check
	def verifyType (UnaryMinusExpression expr) {
		verifyExpectedType (Forml0Package.Literals::UNARY_MINUS_EXPRESSION__RIGHT,
			expr.right, numericType)
	}
	
	@Check
	def verifyType (NotExpression expr) {
		verifyExpectedType (Forml0Package.Literals::NOT_EXPRESSION__RIGHT, 
			expr.right, booleanType)
	}
	
	@Check
	def verifyType (ProductExpression expr) {
		verifyExpectedType (Forml0Package.Literals::PRODUCT_EXPRESSION__LEFT, 
			expr.left, numericType) 
		verifyExpectedType (Forml0Package.Literals::PRODUCT_EXPRESSION__RIGHT, 
			expr.right, numericType)
	}
	
	@Check
	def verifyQuantity (ProductExpression expr) {
		var qLeft  = expr.left .quantityFor
		var qRight = expr.right.quantityFor
		var q      = expr      .quantityFor
		if ((qLeft.time != 0 && qRight.ticks != 0) || (qLeft.ticks != 0 && qRight.time != 0))
			error ("Multiplying Durations and Clock Ticks", Forml0Package.Literals::PRODUCT_EXPRESSION__RIGHT, WRONG_QUANTITY)
		if (q.ticks > 0 && expr.typeFor != integerType)
			error ("Tick numbers must be Integers", Forml0Package.Literals::PRODUCT_EXPRESSION__RIGHT, WRONG_QUANTITY)
	}
	
	@Check
	def verifyType (DivisionExpression expr) {
		verifyExpectedType (Forml0Package.Literals::DIVISION_EXPRESSION__LEFT, 
			expr.left, numericType)
		verifyExpectedType (Forml0Package.Literals::DIVISION_EXPRESSION__RIGHT, 
			expr.right, numericType)
		if (expr.right.variabilityFor == constant && expr.right.valueFor == 0.0)
			error ("Division by zero since right operand is constant 0", Forml0Package.Literals::DIVISION_EXPRESSION__RIGHT, DIVISION_BY_ZERO)
	}
	
	@Check
	def verifyQuantity (DivisionExpression expr) {
		var qLeft  = expr.left .quantityFor
		var qRight = expr.right.quantityFor
		var q      = expr      .quantityFor
		if ((qLeft.time != 0 && qRight.ticks != 0) || (qLeft.ticks != 0 && qRight.time != 0))
			error ("Dividing Durations and Clock Ticks", Forml0Package.Literals::DIVISION_EXPRESSION__RIGHT, WRONG_QUANTITY)
		if (q.ticks > 0 && expr.typeFor != integerType)
			error ("Tick numbers must be whole numbers", Forml0Package.Literals::DIVISION_EXPRESSION__RIGHT, WRONG_QUANTITY)
//		if (q.ticks < 0)
//			error ("Power for Clock Ticks must not be negative, instead got " + expr.quantityFor.ticks, Forml0Package.Literals::DIVISION_EXPRESSION__RIGHT, WRONG_QUANTITY)
	}
	
	@Check
	def verifyType (IntegerDivisionExpression expr) {
		verifyExpectedType (Forml0Package.Literals::INTEGER_DIVISION_EXPRESSION__LEFT, 
			expr.left, numericType)
		verifyExpectedType (Forml0Package.Literals::INTEGER_DIVISION_EXPRESSION__RIGHT, 
			expr.right, numericType)
	}
	
	@Check
	def verifyQuantity (IntegerDivisionExpression expr) {
		var qLeft  = expr.left .quantityFor
		var qRight = expr.right.quantityFor
		var q      = expr      .quantityFor
		if ((qLeft.time != 0 && qRight.ticks != 0) || (qLeft.ticks != 0 && qRight.time != 0))
			error ("Dividing Durations and Clock Ticks", Forml0Package.Literals::INTEGER_DIVISION_EXPRESSION__RIGHT, WRONG_QUANTITY)
		if (q.ticks > 0 && expr.typeFor != integerType)
			error ("Tick numbers must be whole numbers", Forml0Package.Literals::INTEGER_DIVISION_EXPRESSION__RIGHT, WRONG_QUANTITY)
//		if (q.ticks < 0)
//			error ("Power for Clock Ticks must not be negative, instead got " + expr.quantityFor.ticks, Forml0Package.Literals::INTEGER_DIVISION_EXPRESSION__RIGHT, WRONG_QUANTITY)
	}
	
	@Check
	def verifyType (AdditionExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::ADDITION_EXPRESSION__LEFT, 
			expr.left, numericType,
			           eventType)
		verifyExpected2Types (Forml0Package.Literals::ADDITION_EXPRESSION__RIGHT, 
			expr.right, numericType,
			            eventType)
		if (expr.right.typeFor == eventType && expr.left.typeFor == eventType)
			error ("Adding an Event to an Event: use 'or'", Forml0Package.Literals::ADDITION_EXPRESSION__LEFT, WRONG_TYPE)
	}
	
	@Check
	def verifyQuantity (AdditionExpression expr) {
		var qLeft  = expr.left .quantityFor
		var qRight = expr.right.quantityFor
		var q      = expr      .quantityFor
		if (expr.left .typeFor == eventType && !(qRight.equal (time) || qRight.equal (tick)))
			error ("Not adding a duration to an Event", Forml0Package.Literals::ADDITION_EXPRESSION__RIGHT, WRONG_TYPE)
		if (expr.right.typeFor == eventType && !(qLeft .equal (time) || qLeft .equal (tick)))
			error ("Not adding a duration to an Event", Forml0Package.Literals::ADDITION_EXPRESSION__LEFT , WRONG_TYPE)
		if (expr.left .typeFor != eventType && expr.right.typeFor != eventType && !qLeft.equal (qRight))
			error ("Adding a " + qLeft.toString + " to a " + qRight.toString, Forml0Package.Literals::ADDITION_EXPRESSION__RIGHT, WRONG_QUANTITY)
		if (q.ticks > 0 && expr.typeFor != integerType)
			error ("Tick numbers must be Integers", Forml0Package.Literals::ADDITION_EXPRESSION__RIGHT, WRONG_QUANTITY)
	}
	
	@Check
	def verifyType (SubstractionExpression expr) {
		verifyExpectedType (Forml0Package.Literals::SUBSTRACTION_EXPRESSION__LEFT, 
			expr.left, numericType)
		verifyExpectedType (Forml0Package.Literals::SUBSTRACTION_EXPRESSION__RIGHT, 
			expr.right, numericType)
	}
	
	@Check
	def verifyQuantity (SubstractionExpression expr) {
		var qLeft  = expr.left .quantityFor
		var qRight = expr.right.quantityFor
		var q      = expr      .quantityFor
		if (!qLeft.equal (qRight))
			error ("Adding a " + qLeft.toString + " to a " + qRight.toString, Forml0Package.Literals::SUBSTRACTION_EXPRESSION__RIGHT, WRONG_QUANTITY)
		if (q.ticks > 0 && expr.typeFor != integerType)
			error ("Tick numbers must be Integers", Forml0Package.Literals::SUBSTRACTION_EXPRESSION__RIGHT, WRONG_QUANTITY)
	}
	
	@Check
	def verifyType (WithoutExpression expr) {
		verifyExpectedType (Forml0Package.Literals::WITHOUT_EXPRESSION__LEFT, 
			expr.left, eventType)
		verifyExpectedType (Forml0Package.Literals::WITHOUT_EXPRESSION__RIGHT, 
			expr.right, eventType)
	}
	
	@Check
	def verifyType (FollowingExpression expr) {
		verifyExpectedType (Forml0Package.Literals::FOLLOWING_EXPRESSION__LEFT, 
			expr.left, eventType)
		verifyExpectedType (Forml0Package.Literals::FOLLOWING_EXPRESSION__RIGHT, 
			expr.right, eventType)
	}
	
	@Check
	def verifyType (EqualityExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::EQUALITY_EXPRESSION__LEFT, 
			expr.left, booleanType,
					   numericType)
		verifyExpected2Types (Forml0Package.Literals::EQUALITY_EXPRESSION__RIGHT, 
			expr.right, booleanType,
						numericType)
		verifyTypesCompatibility (Forml0Package.Literals::EQUALITY_EXPRESSION__RIGHT, 
			expr.left, expr.right)
	}
	
	@Check
	def verifyQuantity (EqualityExpression expr) {
		var qLeft  = expr.left .quantityFor
		var qRight = expr.right.quantityFor
		if (!qLeft.equal (qRight))
			error ("Comparing a " + qLeft.toString + " to a " + qRight.toString, Forml0Package.Literals::EQUALITY_EXPRESSION__RIGHT, WRONG_QUANTITY)
	}
	
	@Check
	def verifyType (DifferenceExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::DIFFERENCE_EXPRESSION__LEFT, 
			expr.left, booleanType,
					   numericType)
		verifyExpected2Types (Forml0Package.Literals::DIFFERENCE_EXPRESSION__RIGHT, 
			expr.right, booleanType,
						numericType)
		verifyTypesCompatibility (Forml0Package.Literals::DIFFERENCE_EXPRESSION__RIGHT, 
			expr.left, expr.right)
	}
	
	@Check
	def verifyQuantity (DifferenceExpression expr) {
		var qLeft  = expr.left .quantityFor
		var qRight = expr.right.quantityFor
		if (!qLeft.equal (qRight))
			error ("Comparing a " + qLeft.toString + " to a " + qRight.toString, Forml0Package.Literals::DIFFERENCE_EXPRESSION__RIGHT, WRONG_QUANTITY)
	}
	
	@Check
	def verifyType (LessThanExpression expr) {
		verifyExpectedType (Forml0Package.Literals::LESS_THAN_EXPRESSION__LEFT, 
			expr.left, numericType)
		verifyExpectedType (Forml0Package.Literals::LESS_THAN_EXPRESSION__RIGHT, 
			expr.right, numericType)
	}
	
	@Check
	def verifyQuantity (LessThanExpression expr) {
		var qLeft  = expr.left .quantityFor
		var qRight = expr.right.quantityFor
		if (!qLeft.equal (qRight))
			error ("Comparing a " + qLeft.toString + " to a " + qRight.toString, Forml0Package.Literals::LESS_THAN_EXPRESSION__RIGHT, WRONG_QUANTITY)
	}
	
	@Check
	def verifyType (LessOrEqualExpression expr) {
		verifyExpectedType (Forml0Package.Literals::LESS_OR_EQUAL_EXPRESSION__LEFT, 
			expr.left, numericType)
		verifyExpectedType (Forml0Package.Literals::LESS_OR_EQUAL_EXPRESSION__RIGHT, 
			expr.right, numericType)
	}
	
	@Check
	def verifyQuantity (LessOrEqualExpression expr) {
		var qLeft  = expr.left .quantityFor
		var qRight = expr.right.quantityFor
		if (!qLeft.equal (qRight))
			error ("Comparing a " + qLeft.toString + " to a " + qRight.toString, Forml0Package.Literals::LESS_OR_EQUAL_EXPRESSION__RIGHT, WRONG_QUANTITY)
	}
	
	@Check
	def verifyType (GreaterThanExpression expr) {
		verifyExpectedType (Forml0Package.Literals::GREATER_THAN_EXPRESSION__LEFT, 
			expr.left, numericType)
		verifyExpectedType (Forml0Package.Literals::GREATER_THAN_EXPRESSION__RIGHT, 
			expr.right, numericType)
	}
	
	@Check
	def verifyQuantity (GreaterThanExpression expr) {
		var qLeft  = expr.left .quantityFor
		var qRight = expr.right.quantityFor
		if (!qLeft.equal (qRight))
			error ("Comparing a " + qLeft.toString + " to a " + qRight.toString, Forml0Package.Literals::GREATER_THAN_EXPRESSION__RIGHT, WRONG_QUANTITY)
	}
	
	@Check
	def verifyType (GreaterOrEqualExpression expr) {
		verifyExpectedType (Forml0Package.Literals::GREATER_OR_EQUAL_EXPRESSION__LEFT, 
			expr.left, numericType)
		verifyExpectedType (Forml0Package.Literals::GREATER_OR_EQUAL_EXPRESSION__RIGHT, 
			expr.right, numericType)
	}
	
	@Check
	def verifyQuantity (GreaterOrEqualExpression expr) {
		var qLeft  = expr.left .quantityFor
		var qRight = expr.right.quantityFor
		if (!qLeft.equal (qRight))
			error ("Comparing a " + qLeft.toString + " to a " + qRight.toString, Forml0Package.Literals::GREATER_OR_EQUAL_EXPRESSION__RIGHT, WRONG_QUANTITY)
	}
	
	@Check
	def verifyType (AndExpression expr) {
		verifyExpectedType (Forml0Package.Literals::AND_EXPRESSION__LEFT, 
			expr.left, booleanType)
		verifyExpectedType (Forml0Package.Literals::AND_EXPRESSION__RIGHT, 
			expr.right, booleanType)
	}
	
	@Check
	def verifyType (WhileExpression expr) {
		verifyExpectedType (Forml0Package.Literals::WHILE_EXPRESSION__LEFT, 
			expr.left, eventType)
		verifyExpected2Types (Forml0Package.Literals::WHILE_EXPRESSION__RIGHT, 
			expr.right, booleanType,
			            eventType)
	}
	
	@Check
	def verifyType (OrExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::OR_EXPRESSION__LEFT, 
			expr.left, booleanType,
					   eventType)
		verifyExpected2Types (Forml0Package.Literals::OR_EXPRESSION__RIGHT, 
			expr.right, booleanType,
						eventType)
		verifyTypesCompatibility (Forml0Package.Literals::OR_EXPRESSION__RIGHT, 
			expr.left, expr.right)
	}
	
	@Check
	def verifyType (XorExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::XOR_EXPRESSION__LEFT, 
			expr.left, booleanType,
					   eventType)
		verifyExpected2Types (Forml0Package.Literals::XOR_EXPRESSION__RIGHT, 
			expr.right,booleanType,
						eventType)
		verifyTypesCompatibility (Forml0Package.Literals::XOR_EXPRESSION__RIGHT, 
			expr.left, expr.right)
	}
	
	@Check
	def verifyType (IfExpression expr) {
		verifyTypesCompatibility (Forml0Package.Literals::IF_EXPRESSION__ELSE, 
			expr.then, expr.^else)
	}
	
	@Check
	def verifyQuantity (IfExpression expr) {
		var qThen = expr. then ?.quantityFor ?: scalar
		var qElse = expr.^else ?.quantityFor ?: scalar
		if (!qThen.equal (qElse))
			error ("Comparing a " + qThen.toString + " to a " + qElse.toString, Forml0Package.Literals::IF_EXPRESSION__ELSE, WRONG_QUANTITY)
	}
	
	@Check
	def verifyType (ChangesExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::CHANGES_EXPRESSION__EXPRESSION, 
			expr.expression, booleanType,
					         numericType)
	}
	
	@Check
	def verifyType (BecomesExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::BECOMES_EXPRESSION__EXPRESSION, 
			expr.expression, booleanType,
					         numericType)
	}
	
	@Check
	def verifyType (LeavesExpression expr) {
		verifyExpected2Types (Forml0Package.Literals::LEAVES_EXPRESSION__EXPRESSION, 
			expr.expression, booleanType,
					         numericType)
	}
	
	@Check
	def verifyType (FirstExpression expr) {
		verifyExpectedType (Forml0Package.Literals::FIRST_EXPRESSION__RIGHT, 
			expr.right, eventType)
	}
	
	@Check
	def verifyType (DropExpression expr) {
		verifyExpectedType (Forml0Package.Literals::DROP_EXPRESSION__RIGHT, 
			expr.right, eventType)
	}
	
	@Check
	def verifyType (EventExpression expr) {
		verifyExpectedType (Forml0Package.Literals::EVENT_EXPRESSION__EXPRESSION, 
			expr.expression, eventType)
	}
	
	@Check
	def verifyType (NumericExpression expr) {
		verifyExpectedType (Forml0Package.Literals::NUMERIC_EXPRESSION__EXPRESSION, 
			expr.expression, numericType)
	}
	
	@Check
	def verifyType (IntegerExpression expr) {
		verifyExpectedType (Forml0Package.Literals::INTEGER_EXPRESSION__EXPRESSION, 
			expr.expression, integerType)
	}
	
	@Check
	def verifyType (BooleanExpression expr) {
		verifyExpectedType (Forml0Package.Literals::BOOLEAN_EXPRESSION__EXPRESSION, 
			expr.expression, booleanType)
	}
	
	@Check
	def verifyType (During expr) {
		verifyExpected2Types (Forml0Package.Literals::DURING__CONDITION, 
			expr.condition, booleanType,
						    ctlType)
	}
	
	def private Forml0Variability getItemVariabilityAndCheckNotNull (Item item, EReference reference) {
		if (item                 === null) error ("Item undefined", reference, WRONG_VARIABILITY)
		if (item?.variabilityFor === null) error ("Variability undefined", reference, WRONG_VARIABILITY)
		return item?.variabilityFor
	}

	@Check
	def verifyVariability (Boolean item) {
		var variability = getItemVariabilityAndCheckNotNull (item, Forml0Package.Literals::BOOLEAN__BOOLEAN_DEFINITION)
 		if (item?.constant && variability != constant) 
 			error ("Expected a constant expression, but got a " + variability.toString + " expression ",
 				  Forml0Package.Literals::BOOLEAN__BOOLEAN_DEFINITION, WRONG_VARIABILITY)
 		else if (item?.fixed && variability != constant && variability != fixed)
 			error ("Expected a fixed expression, but got a " + variability.toString + " expression ",
 				  Forml0Package.Literals::BOOLEAN__BOOLEAN_DEFINITION, WRONG_VARIABILITY)
	}
		
	@Check
	def verifyExternal (Boolean item) {
 		if (item?.parameters?.size > 0 && !item?.booleanDefinition?.external)    
 			error ("In Form-L0, Boolean definitions with parameters other than time must be external", Forml0Package.Literals::BOOLEAN__BOOLEAN_DEFINITION, NOT_EXTERNAL)
	}
		
	@Check
	def verifyClock (BooleanStatement statement) {
		if (statement.discrete) {
			var definition = statement.getContainerOfType(typeof(Boolean))?.booleanDefinition
			if (definition === null) 
 				error ("Unexpected Boolean statement",
 					Forml0Package.Literals::BOOLEAN_STATEMENT__DISCRETE, NO_CLOCK)
			if (!definition.clock) {
 				error ("Discrete rate, but item being defined does not have a clock",
 					Forml0Package.Literals::BOOLEAN_STATEMENT__DISCRETE, NO_CLOCK)
			}
		}
	}
		
	@Check
	def verifyVariability (Integer item) {
		var variability = getItemVariabilityAndCheckNotNull (item, Forml0Package.Literals::INTEGER__INTEGER_DEFINITION)
 		if (item?.constant && variability != constant) 
 			error ("Expected a constant expression, but got a " + variability.toString + " expression ",
 				  Forml0Package.Literals::INTEGER__INTEGER_DEFINITION, WRONG_VARIABILITY)
 		else if (item?.fixed && variability != constant && variability != fixed)
 			error ("Expected a fixed expression, but got a " + variability.toString + " expression ",
 				  Forml0Package.Literals::INTEGER__INTEGER_DEFINITION, WRONG_VARIABILITY)
	}
	
	@Check
	def verifyQuantity (Integer item) {
		if (item.integerDefinition.global && !item.integerDefinition.external) {
			var q = item.integerDefinition.globalValue?.expression?.quantityFor
			if (!q.equal(scalar))
				error ("Expected a scalar, but got a " + q.toString + " expression ",
 				  Forml0Package.Literals::INTEGER__INTEGER_DEFINITION, WRONG_QUANTITY)	
		} 
		var statements = item.integerDefinition.statements
		if (statements !== null) {
			var int i
			for (i=0; i < statements.size; i++) {
				if (statements.get(i).value !== null) {
					var q = statements.get(i).value.expression.quantityFor
					if (!q.equal(scalar))
						error ("Expected a scalar, but got a " + q.toString + " expression ",
 				  			Forml0Package.Literals::INTEGER__INTEGER_DEFINITION, WRONG_QUANTITY)
 				}
				if (statements.get(i).rateValue !== null) {
					var q = statements.get(i).rateValue.expression.quantityFor
					if (!q.equal(rate))
						error ("Expected a rate, but got a " + q.toString + " expression ",
 				  			Forml0Package.Literals::INTEGER__INTEGER_DEFINITION, WRONG_QUANTITY)
 				}
			}
		}
	}
		
	@Check
	def verifyExternal (Integer item) {
 		if (item?.parameters?.size > 0 && !item?.integerDefinition?.external)    
 			error ("In Form-L0, Integer definitions with parameters other than time must be external", Forml0Package.Literals::INTEGER__INTEGER_DEFINITION, NOT_EXTERNAL)
	}
		
	@Check
	def verifyClock (IntegerStatement statement) {
		if (statement.discrete) {
			var definition = statement.getContainerOfType(typeof(Integer))?.integerDefinition
			if (definition === null) 
 				error ("Unexpected Integer statement",
 					Forml0Package.Literals::INTEGER_STATEMENT__DISCRETE, NO_CLOCK)
			if (!definition.clock) {
 				error ("Discrete rate, but item being defined does not have a clock",
 					Forml0Package.Literals::INTEGER_STATEMENT__DISCRETE, NO_CLOCK)
			}
		}
	}
		
	@Check
	def verifyVariability (Real item) {
		var variability = getItemVariabilityAndCheckNotNull (item, Forml0Package.Literals::REAL__REAL_DEFINITION)
 		if (item?.constant && variability != constant) 
 			error ("Expected a constant expression, but got a " + variability.toString + " expression ",
 				  Forml0Package.Literals::REAL__REAL_DEFINITION, WRONG_VARIABILITY)
 		else if (item?.fixed && variability != constant && variability != fixed)
 			error ("Expected a fixed expression, but got a " + variability.toString + " expression ",
 				  Forml0Package.Literals::REAL__REAL_DEFINITION, WRONG_VARIABILITY)
	}
	
	@Check
	def verifyQuantity (Real item) {
		if (item.realDefinition.global && !item.realDefinition.external) {
			var q = item.realDefinition.globalValue?.expression?.quantityFor
			if (!q.equal(scalar))
				error ("Expected a scalar, but got a " + q.toString + " expression ",
 				  Forml0Package.Literals::REAL__REAL_DEFINITION, WRONG_QUANTITY)	
		}
		var statements = item.realDefinition.statements
		if (statements !== null) {
			var int i
			for (i=0; i < statements.size; i++) {
				if (statements.get(i).attribute !== null && statements.get(i).value !== null) {
					var q = statements.get(i).value.expression.quantityFor
					if (!q.equal(scalar))
						error ("Expected a scalar, but got a " + q.toString + " expression ",
 				  			Forml0Package.Literals::REAL__REAL_DEFINITION, WRONG_QUANTITY)
  				}
				if (statements.get(i).rateValue !== null) {
					var q = statements.get(i).rateValue.expression.quantityFor
					if (!q.equal(rate))
						error ("Expected a rate, but got a " + q.toString + " expression ",
 				  			Forml0Package.Literals::REAL__REAL_DEFINITION, WRONG_QUANTITY)
  				}
 				if (statements.get(i).derivative && statements.get(i).ranked) { 
 					var q = statements.get(i).value.expression.quantityFor
 					var s = new Forml0Quantity(-statements.get(i).rank, 0)
					if (!q.equal(s))	
						error ("Expected a " + s.toString + ", but got a " + q.toString + " expression ",
 				  			Forml0Package.Literals::REAL__REAL_DEFINITION, WRONG_QUANTITY)
 				}
 				if (statements.get(i).derivative && !statements.get(i).ranked) { 
 					var q = statements.get(i).value.expression.quantityFor
					if (!q.equal(rate))	
						error ("Expected a rate, but got a " + q.toString + " expression ",
 				  			Forml0Package.Literals::REAL__REAL_DEFINITION, WRONG_QUANTITY)
 				}
			}
		}
	}
		
	@Check
	def verifyExternal (Real item) {
 		if (item?.parameters?.size > 0 && !item.realDefinition?.external)    
 			error ("In Form-L0, Real definitions with parameters other than time must be external", Forml0Package.Literals::REAL__REAL_DEFINITION, NOT_EXTERNAL)
	}
		
	@Check
	def verifyClock (NumericStatement statement) {
		if (statement.discrete) {
			var definition = statement.getContainerOfType(typeof(Real))?.realDefinition
			if (definition === null) 
 				error ("Unexpected numeric statement",
 					Forml0Package.Literals::NUMERIC_STATEMENT__DISCRETE, NO_CLOCK)
			if (!definition.clock) {
 				error ("Discrete rate, but item being defined does not have a clock",
 					Forml0Package.Literals::NUMERIC_STATEMENT__DISCRETE, NO_CLOCK)
			}
		}
	}
		
	@Check
	def verifyExternal (Event item) {
 		if (item?.parameters?.size > 0 && !item?.eventDefinition?.external)    
 			error ("In Form-L0, Event definitions with parameters other than time must be external", Forml0Package.Literals::EVENT__EVENT_DEFINITION, NOT_EXTERNAL)
	}
		
	@Check
	def verifyClock (EventStatement statement) {
		if (statement.discrete) {
			var definition = statement.getContainerOfType(typeof(Event))?.eventDefinition
			if (definition === null) 
 				error ("Unexpected event statement",
 					Forml0Package.Literals::EVENT_STATEMENT__DISCRETE, NO_CLOCK)
			if (!definition.clock) {
 				error ("Discrete rate, but item being defined does not have a clock",
 					Forml0Package.Literals::EVENT_STATEMENT__DISCRETE, NO_CLOCK)
			}
		}
	}
		
	@Check
	def verifyConstraintType (PropertyDefinition p) {
		if (p?.achieve && p.constraint.expression.constraintCategoryFor == notELSConstraint)
			error ("The constraint is not suitable for an 'achieve' Property", Forml0Package.Literals::PROPERTY_DEFINITION__CONSTRAINT, WRONG_CONSTRAINT)
	}
	
	@Check
	def verifyDuration (DurationExpression d) {
		var q = d.expression.quantityFor
		if (!q.equal(rate) && !q.equal(tick))
			error ("Incorrect quantity for a duration, this one is " + q, Forml0Package.Literals::DURATION_EXPRESSION__EXPRESSION, WRONG_QUANTITY)
		if (q.equal(tick)) verifyExpectedType (Forml0Package.Literals::DURATION_EXPRESSION__EXPRESSION, 
			d.expression, integerType)
		var item = d.getContainerOfType(typeof(Item))
		if (q.equal(tick) && item === null) 
			error ("Use of ticks without a containing item", Forml0Package.Literals::DURATION_EXPRESSION__EXPRESSION, WRONG_DURATION)
		if (item.^boolean !== null) {
			if (!(item.^boolean as Boolean).booleanDefinition.clock) 
				error ("Use of ticks when containing Boolean does not have a clock ", Forml0Package.Literals::DURATION_EXPRESSION__EXPRESSION, WRONG_DURATION)
		}	
		if (item.integer !== null) {
			if (!(item.integer as Integer).integerDefinition.clock) 
				error ("Use of ticks when containing Integer does not have a clock ", Forml0Package.Literals::DURATION_EXPRESSION__EXPRESSION, WRONG_DURATION)
		}
		if (item.real !== null) {
			if (!(item.real as Real).realDefinition.clock) 
				error ("Use of ticks when containing Real does not have a clock ", Forml0Package.Literals::DURATION_EXPRESSION__EXPRESSION, WRONG_DURATION)
		}
		if (item.event !== null) {
			if (!(item.event as Event).eventDefinition.clock) 
				error ("Use of ticks when containing Event does not have a clock ", Forml0Package.Literals::DURATION_EXPRESSION__EXPRESSION, WRONG_DURATION)
		}
		if (item.property !== null) {
			if (!(item.^property as Property).propertyDefinition.clock) 
				error ("Use of ticks when containing Property does not have a clock ", Forml0Package.Literals::DURATION_EXPRESSION__EXPRESSION, WRONG_DURATION)
		}
		if (item.ctl !== null) {
			if (!(item.^ctl as Ctl).ctlDefinition.clock) 
				error ("Use of ticks when containing Ctl does not have a clock ", Forml0Package.Literals::DURATION_EXPRESSION__EXPRESSION, WRONG_DURATION)
		}
		if (d.expression.variabilityFor == constant && d.expression.valueFor <= 0.0)
			error ("Constant durations must be strictly positive, and this one is " + d.expression.valueFor, Forml0Package.Literals::DURATION_EXPRESSION__EXPRESSION, WRONG_DURATION)
	}
	
	@Check
	def verifyDuration (RateExpression r) {
		if (!r.expression.quantityFor.equal(rate))  
			error ("Expected a rate, got a " + r.expression.quantityFor.toString, Forml0Package.Literals::RATE_EXPRESSION__EXPRESSION, WRONG_RATE)
		if (r.expression.variabilityFor == constant && r.expression.valueFor <= 0.0)
			error ("Constant rates must be strictly positive, and this one is " + r.expression.valueFor, Forml0Package.Literals::RATE_EXPRESSION__EXPRESSION, WRONG_RATE)
	}
	
	@Check
	def verifyDuration (DiscreteRateExpression r) {
		if (!r.expression.quantityFor.equal(tick))  
			error ("Expected a tick rate, got a " + r.expression.quantityFor.toString, Forml0Package.Literals::DISCRETE_RATE_EXPRESSION__EXPRESSION, WRONG_RATE)
		if (r.expression.variabilityFor == constant && r.expression.valueFor <= 0.0)
			error ("Constant tick rates must be strictly positive, and this one is " + r.expression.valueFor, Forml0Package.Literals::DISCRETE_RATE_EXPRESSION__EXPRESSION, WRONG_RATE)
	}
	
}	

	