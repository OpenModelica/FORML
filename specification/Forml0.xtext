grammar edf.Forml0 with org.eclipse.xtext.common.Terminals
// Absolute minimal FORM-L subset:
//	- Single, flat name space
//	- Only Booleans, Integers, Reals, Events / DTLs, CTLs and Properties
//	- Single combined declaration & definition for each
//	- Parameters other than time only for external variables and events
//	- Forward references allowed
//	- No local items for variables and events
//	- No default value, no derivatives, no integrals
//	- No declaration of visibility 
//	- No sets, no spatial locators
//	- No defined types
//	- No sliding time locators (STL), no time exclusion (otherwise)
//	- No composite statements
//	- No objects, no classes
//	- No contracts, no standard contracts
//	- No refinements, no refinement models
//	- No partial models, no libraries
//	- No Guarantee properties

generate forml0 "http://www.Forml0.edf"

Model:
	items+=Item*;
	
Item:
	boolean=Boolean
|	integer=Integer
|	real=Real
|	event=Event
|	ctl=Ctl
|	property=Property
;
 
Boolean returns Item:
	{Boolean} (constant?='constant' | fixed?='fixed')? type='Boolean' name=ID Parameters? booleanDefinition=BooleanDefinition ';'
	/// Verify name is unique
	// Verify, if there are parameters, that definition is external
	/// Verify, if constant or fixed, that definition is global, and that the value given is itself constant or fixed
	/// Variability 
	///	- If declared constant or fixed, then as declared 
	///	- If variability not declared and global value definition, then as global value
	///	- Else, normal
;

Integer returns Item:
	{Integer} (constant?='constant' | fixed?='fixed')? type='Integer' name=ID integerDefinition=IntegerDefinition ';'
	/// Verify name is unique
	// Verify, if there are parameters, that definition is external
	/// Verify, if constant or fixed, that definition is global, and that the value given is itself constant or fixed
	/// Variability: same rule as for Boolean
;

Real returns Item:
	{Real} (constant?='constant' | fixed?='fixed')? type='Real' name=ID realDefinition=RealDefinition ';'
	/// Verify name is unique
	// Verify, if there are parameters, that definition is external
	/// Verify, if constant or fixed, that definition is global, and that the value given is itself constant or fixed
	/// Variability: same rule as for Boolean
;

Event returns Item:
	{Event} type='Event' name=ID Parameters? eventDefinition=EventDefinition ';'
	/// Verify name is unique
	// Verify, if there are parameters, that definition is external
;

fragment Parameters *:
	'(' parameters+=Parameter? (',' parameters+=Parameter?)* ')'
; 

Parameter:
	(constant?='constant' | fixed?='fixed')? type=('Boolean' | 'Integer' | 'Real' | 'Event')
;

BooleanDefinition:
	{GlobalBooleanDefinition}   'is' globalValue=BooleanExpression 
|	{ExternalBooleanDefinition} 'is' 'external'
|	{ItemizedBooleanDefinition} 
		'begin' 
		('clock' 'is' clock=EventExpression ';')? 
		('value' 'is' value=BooleanExpression ';' | statements+=BooleanStatement+)? 
		'end'
;

BooleanStatement: {BooleanStatement} 
	timeLocator=TimeLocator 'define' attribute=AssignableVariableAttribute 'is' value=BooleanExpression ';'
;

IntegerDefinition:
	{GlobalIntegerDefinition}   'is' globalValue=IntegerExpression 
|	{ExternalIntegerDefinition} 'is' 'external'
|	{ItemizedIntegerDefinition} 
		'begin' 
		('clock' 'is' clock=EventExpression ';')? 
		('value' 'is' value=IntegerExpression ';' | statements+=IntegerStatement+)? 
		'end'
;

IntegerStatement: {IntegerStatement} 
	timeLocator=TimeLocator 'define' attribute=AssignableVariableAttribute 'is' value=IntegerExpression ';'
;

RealDefinition:
	{GlobalRealDefinition}   'is' globalValue=NumericExpression 
|	{ExternalRealDefinition} 'is' 'external'
|	{ItemizedRealDefinition} 
		'begin' 
		('clock' 'is' clock=EventExpression ';')? 
		('value' 'is' value=NumericExpression ';' | statements+=NumericStatement+)? 
		'end'
;

NumericStatement: {NumericStatement} 
	timeLocator=TimeLocator 'define' attribute=AssignableVariableAttribute 'is' value=NumericExpression ';'
;

AssignableVariableAttribute: 
	'value'
|	'next'
;

EventDefinition:
	{GlobalEventDefinition} 'is' globalOccurrence=EventExpression
|	{ExternalEventDefinition} 'is' 'external'
|	{ItemizedEventDefinition} 
		'begin' 
		('clock' 'is' clock=EventExpression ';')? 
		(statement=GlobalEventStatement | statements+=EventStatement+)? 
		'end'
;

GlobalEventStatement:
	{GlobalEventOccurrence} 'occurrence' 'is' globalOccurrence=EventExpression ';'
|	{GlobalEventRate}       'rate'       'is' rate=            NumericLiteral  ';'
;

EventStatement:
	ctl=CtlExpression   'define' ('occurrence' 'is' occurrence=EventExpression | 'rate' 'is' rate=NumericLiteral)';' 
|	dtl=DtlExpression	('define' 'occurrence' 'is' occurrence=EventExpression | 'signal' 'occurrence')                              ';'
;

Property returns Item:
	{Property} type=PropertyType name=ID 'is' (timeLocator=TimeLocator)? ConstraintType constraint=BooleanExpression ';'
	/// Verify name is unique
	/// Verify, if constraintType is 'achieve' or 'can achieve' or 'can achieve at closing', that
	///	constraint is a comparison between a monotonic expression and a constant or fixed expression, or two opposite monotonic
;

PropertyType:
	'Property'
|	'Objective'
|	'Assumption'
|	'Requirement'
|	'Guard'
;

fragment ConstraintType *:
	(cna?='can')? (achieve?='achieve' (atClosing?='at' 'closing')? | ensure?='ensure')
;

Ctl returns Item: 
	{Ctl} type='Ctl' name=ID 'is' value=CtlExpression ';'
	/// Verify name is unique
;
	
TimeLocator:
	DtlExpression 
|	CtlExpression
;


DtlExpression:
	'when'? EventExpression
	// To be improved
;

CtlExpression:
	FlatCtl (
		{CtlEscapeFrom .left=current} 'escape' 'from'    right=EventExpression 
	|	{CtlEscapeAfter.left=current} 'escape' 'after'   right=EventExpression 
	|	{CtlExitFrom   .left=current} 'exit'   'from'    right=EventExpression 
	|	{CtlExitAfter  .left=current} 'exit'   'after'   right=EventExpression 
	)?
;
 
FlatCtl returns CtlExpression:
	{FlatCtl} 'flat' ctl=OrCtl
|	OrCtl
;


OrCtl returns CtlExpression:
	NotCtl ({OrCtl.left=current} 'also' right=NotCtl)*
;

NotCtl returns CtlExpression:
	{NotCtl} 'except' ctl=ModifiedCtl
|	ModifiedCtl
;

ModifiedCtl returns CtlExpression:
	BasicCtl 
	(	{CtlDelayed    .left=current} 'delayed'         right=Duration
	|	{CtlExceptBool .left=current} 'except' 'during' right=BooleanExpression
	|	{CtlExceptEvent.left=current} 'except' 'when'   right=EventExpression
	|	{CtlExceptFirst.left=current} 'except' 'first'  right=Duration
	|	{CtlDuring     .left=current} 'during'          right=BooleanExpression
	)*
;

BasicCtl returns CtlExpression:
	{Always}  'always'
|	{During}  'during' (condition=Expression)
	/// Verify expression is a Boolean or a Ctl
|	{From}    'from'   bop=EventExpression (('until' | 'before') eop=EventExpression | ('for' | 'within') duration=Duration)?
|	{After}   'after'  bop=EventExpression (('until' | 'before') eop=EventExpression | ('for' | 'within') duration=Duration)?  
|	{Before}  'before' eop=EventExpression
|	{Until}   'until'  eop=EventExpression  
|	{For}     'for'    duration=Duration 
|	{Within}  'within' duration=Duration 

|	{FromEveryFor}     'from'  'every' duration1=Duration ('for' | 'within') duration2=Duration 
	/// Verify duration1 and duration2 are constant or fixed
|	{AfterEveryFor}    'after' 'every' duration1=Duration ('for' | 'within') duration2=Duration 
	/// Verify duration1 and duration2 are constant or fixed
;

Duration:
	NumericExpression
;

Domain: 
 	intervals+=ValueOrInterval
|	'{' intervals+=ValueOrInterval (',' intervals+=ValueOrInterval)* '}'
;

ValueOrInterval:
	value=VariableExpression
|	interval=Interval
; 

Interval:
	{Interval} (bb?='[' | ']') (lb=NumericExpression)? ',' (ub=NumericExpression)? ('[' | eb?=']')
|	{IntegerInterval} (negativeLb?='-' intLb=INT)? '..' (negativeUb?='-' intUb=INT)?;

BooleanExpression:
	expression=IfExpression
	/// Verify expression is a Boolean
;

IntegerExpression:
	expression=IfExpression
	/// Verify expression is an integer
;

NumericExpression:
	expression=IfExpression	
	/// Verify expression is numeric
;

EventExpression:
	expression=Expression
	/// Verify expression is an event
;

VariableExpression: 
	IfExpression
;

Expression:
	/// An expression can be a Boolean, a number or an event
	/// Not all expression operators are allowed for certain of these types
 	IfExpression  
	(	{ChangesExpression.expression=current} 'changes'
	/// Verify expression is a Boolean or a numeric
	/// Result is an event
	|	{BecomesExpression.expression=current} 'becomes' target=Domain 
	/// Verify expression is a Boolean or a numeric
	/// Result is an event
	|	{LeavesExpression .expression=current} 'leaves'  origin=Domain ('becomes' target=Domain)?
	/// Verify expression is a Boolean or a numeric
	/// Result is an event
	)?
|	{EveryExpression} 'at' 'every' duration=Duration
	// AT added to overcome parsing problems
	/// Result is an event
;

IfExpression returns Expression:
	XorExpression
|	{IfExpression} 'if' condition=BooleanExpression 'then' then=XorExpression 'else' else=IfExpression
	// The else part is not optional, since otherwise there would be no value for the expression
	/// Verify then and else are both Boolean, both events, or both numeric
	/// Result is an integer if then and else are integers
	/// Result is a real if then and else are numeric and one is a real
	/// Result is of the same type as then if it is a Boolean or an event
	// Variability
	///	- If all three are constant, then constant
	///	- If condition if fixed, and both branches are constant or fixed, then fixed
	///	- Else normal
;

XorExpression returns Expression:
	OrExpression (
		{XorExpression.left=current} 'xor' right=OrExpression
		/// Verify both left and right are Booleans, or both are events
		/// Result is of the same type as left
		/// Variability
		///	- If both are constant, then constant
		///	- If both are fixed, or one is fixed and the other constant, then fixed
		///	- Else normal
	)?
;

OrExpression returns Expression:
	AndExpression (
		{OrExpression.left=current} 'or' right=AndExpression
		/// Verify both left and right are Booleans, or both are events
		/// Result is of the same type as left
		/// Variability
		///	- If both are constant, then constant
		///	- If both are fixed, or one is fixed and the other constant, then fixed
		///	- Else normal
	)*
;

AndExpression returns Expression:
	EquationExpression (
		{AndExpression.left=current} 'and' right=EquationExpression
		/// Verify both are Booleans
		/// Result is a Boolean
		/// Variability
		///	- If both are constant, then constant
		///	- If both are fixed, or one is fixed and the other constant, then fixed
		///	- Else normal
	|	{WhileExpression.left=current} 'while' right=EquationExpression
		/// Verify left is an event and right is an event or a Boolean
		/// Result is an event
	)*
;

EquationExpression returns Expression:
	OrderingExpression (
		/// Variability for all
		///	- If both are constant, then constant
		///	- If both are fixed, or one is fixed and the other constant, then fixed
		///	- Else normal
		{EqualityExpression    .left=current} '='  right=OrderingExpression
		/// Verify both left and right are Booleans, or both are numeric
		/// Result is a Boolean
	|	{DifferenceExpression  .left=current} '<>' right=OrderingExpression
		/// Verify both left and right are Booleans, or both are numeric
		/// Result is a Boolean
	)?
;

OrderingExpression returns Expression:
	MinusExpression (
		/// Variability for all
		///	- If both are constant, then constant
		///	- If both are fixed, or one is fixed and the other constant, then fixed
		///	- Else normal
		{LessThanExpression    .left=current} '<'  right=MinusExpression
		/// Verify both left and right are numeric
		/// Result is a Boolean
	|	{LessOrEqualExpression   .left=current} '<=' right=MinusExpression
		/// Verify both left and right are numeric
		/// Result is a Boolean
	|	{GreaterThanExpression .left=current} '>'  right=MinusExpression
		/// Verify both left and right are numeric
		/// Result is a Boolean
	|	{GreaterOrEqualExpression.left=current} '>=' right=MinusExpression
		/// Verify both left and right are numeric
		/// Result is a Boolean
	)?
;

MinusExpression returns Expression:
	AdditionExpression (
		{SubstractionExpression.left=current} '-' right=AdditionExpression
		/// Verify both left and right are numeric
		/// Result is an integer if left and right are integers, else it is a real
		/// Variability
		///	- If both are constant, then constant
		///	- If both are fixed, or one is fixed and the other constant, then fixed
		///	- If left is increasing and right is constant, fixed or decreasing, then increasing
		///	- If left is decreasing and right is constant, fixed or increasing, then increasing
		///	- Else normal
	|	{WithoutExpression.left=current} 'without' right=AdditionExpression
		/// Verify both left and right are events
		/// Result is an event
	|	{FollowingExpression.left=current} 'following' right=AdditionExpression
		/// Verify both left and right are events
		/// Result is an event
	)?
;

AdditionExpression returns Expression:
	DivisionExpression (
		{AdditionExpression.left=current} '+' right=DivisionExpression
		/// Verify left is numeric or an event, and right is numeric
		/// Result is an integer if left and right are integers
		/// Result is a real if left and right are numeric, and one is a real 
		/// Result is an event if left is an event and right is numeric (a delay)
		// Variability
		///	- If both are constant, then constant
		///	- If both are fixed, or one is fixed and the other constant, then fixed
		///	- If one is increasing and the other constant, fixed or increasing, then increasing
		///	- If one is decreasing and the other constant, fixed or decreasing, then decreasing
		///	- Else normal
	)*
;

DivisionExpression returns Expression:
	ProductExpression (
		{DivisionExpression.left=current} '/' right=ProductExpression
		/// Verify both left and right are numeric
		/// Result is a real
		/// Variability: same rules as for ProductExpression
	|	{IntegerDivisionExpression.left=current} '%' right=ProductExpression
		/// Verify both left and right are numeric
		/// Result is an integer
		/// Variability: same rules as for ProductExpression
	)?
;

ProductExpression returns Expression:
	FirstOrDropExpression (
		{ProductExpression.left=current} '*' right=FirstOrDropExpression
		/// Verify both left and right are numeric
		/// Result is an integer if left and right are integers, else it is a real
		/// Variability
		///	- If both are constant, then constant
		///	- If both are fixed, or one is fixed and the other constant, then fixed
		///	- If one is a positive constant and the other increasing, then increasing
		///	- If one is a negative constant and the other increasing, then decreasing
		///	- If one is a positive constant and the other decreasing, then decreasing
		///	- If one is a negative constant and the other decreasing, then increasing
		///	- Else normal
	)*
;

FirstOrDropExpression returns Expression:
	{FirstExpression} 'first' => ('(' left=INT ')')? right=FirstOrDropExpression
	/// Verify right is an event
	/// Result is an event
|	{DropExpression} 'drop' 'first' => ('(' left=INT ')')? right=FirstOrDropExpression
	/// Verify right is an event
	/// Result is an event
|	NegationExpression
;

NegationExpression returns Expression:
	{UnaryMinusExpression} =>'-' right=PowerExpression
	/// Verify right is numeric
	/// Result is of the same type as right
	// Variability
	///	- If right variability is constant, fixed or normal, then right variability
	///	- If right variability is increasing, then decreasing
	///	- If right variability is decreasing, then increasing
|	{NotExpression} =>'not' right=PowerExpression
	/// Verify right is a Boolean
	/// Result is Boolean
|	PowerExpression
;

PowerExpression returns Expression:
	Atom (
		{PowerExpression.left=current} '^' (negative?='-')? right=INT
		/// Verify left is numeric
		/// Result is of the same type as left
		/// Variability 
		///	- If left variability is constant or fixed, then left variability
		///	- Else if not negative, then left variability 
		///	- Else if negative, variability is normal
	)*	
;

Atom returns Expression:
	/// Numeric (integer or real) atoms
	{NumericLiteral} value=NumericLiteral
	/// Result is an integer or a real
	/// Variability is constant
|	{Time} 'time'
	/// Result is a real
	/// Variability is increasing
|	{inPTime} 'inPTime'
	/// Result is a real
	/// Variability is increasing
|	{MyRate} rate='rate'
	/// Verify currently defined item is an event
	/// Variability 
	///	- If rate is defined globally for currently defined item, then constant
	///	- Else, normal
|	{EventRate} identifier=[Event] '.' 'rate' 
	/// Result is a real
	/// Variability 
	///	- If rate is defined globally for that identifier, then constant
	///	- Else, normal
|	{PropertyRate} identifier=[Property] '.' state=('satisfaction' | 'violation') '.' 'rate' 
	/// Result is a real
	/// Variability is normal
|	{PropertyPfd} identifier=[Property] '.' 'pfd'
	/// Result is a real
	/// Variability is normal
|	{BuiltInFunctionCall} function=BuiltInFunction '(' argument=Expression ')'
|	'(' Expression ')'
	
	/// Boolean atoms
|	{BooleanLiteral} value=('true' | 'false')
	/// Result is a Boolean
	/// Variability is constant
|	{PropertyState} identifier=[Property] '.' state=('satisfaction' | 'violation')
	/// Result is a Boolean
	/// Variability is normal
|	{BooleanFromCtl} 'boolean' '(' ctl=CtlExpression ')'
	/// Result is a Boolean
	/// Variability is normal

	/// Variable (integer, real or Boolean) atoms
|	{MyValue} attribute=('value' | 'previous')
	/// Verify currently defined item is a variable
	/// Result is of the type of currently defined item
	/// Variability is the same as variability of currently defined item
|	{Value} identifier=[Item] ('.' attribute=('value' | 'previous'))
	/// Verify identifier is a Boolean, an Integer or a Real
	/// Result is of the type of variable
	/// Variability is the same as variability of identifier
	
	/// Event atoms
|	{EventLiteral} 't0'
	/// Result is an event
|	{PropertyEvent} identifier=[Property] '.' event=('eSatisfaction' | 'eViolation')
	/// Result is an event
|	{MyClock} clock='clock'
	/// Verify currently defined item is a variable or an event
	/// Result is an event
|	{Clock} identifier=[Item] '.' 'clock'
	/// Verify identifier is a Boolean, an Integer, a Real or an Event
	/// Result is an event

	/// Variable or event atoms
|	{Reference} identifier=[Item] 
	/// Verify identifier is a variable, an Event or a Ctl
	/// Result is of the type of identifier
	// Variability is variability of identifier
|	{FunctionCall} function=[Item] '(' argument=Expression ')'
	// Verify function is a variable or an event
	// Verify function has parameters
	// Verify number of arguments is equal to number of function parameters
	// Verify each argument type and variability match the specified function parameter type and variability
	// Result type is function type
	// Variability depends on function
;

BuiltInFunction:
	'count'			// (Event)				==>	Integer				increasing
|	'duration'		// (Boolean)			==>	Real				increasing
|	'inPCount'		// (Event)				==>	Integer				increasing
|	'inPDuration'	// (Boolean)			==>	Real				increasing
|	'inPMax'		// (Integer or Real)	==>	Integer or Real		increasing
|	'inPMin'		// (Integer or Real)	==>	Integer or Real		decreasing
|	'inTMax'		// (Integer or Real)	==>	Integer or Real		increasing
|	'inTMin'		// (Integer or Real)	==>	Integer or Real		decreasing
|	'probability'	// (Event)				==>	Real				normal
;
 
NumericLiteral:
	((integerValue=INT (=> decimalValue=DECIMALINT | decimalPoint?='.')?) | decimalValue=DECIMALINT) => exponent=EXPONENT?
	// This definition needs to be improved:
	//	- White spaces are allowed between different parts of the literal, but they should not
	//	- A + or - sign is required after letter e or E
;

terminal DECIMALINT:  '.' ('0'..'9')+;
terminal EXPONENT:	  ('e' | 'E') ('+' | '-') INT;


@Override
terminal ID: ('a'..'z'|'A'..'Z'|'_'|'°') ('a'..'z'|'A'..'Z'|'_'|'°'|'0'..'9')*;
